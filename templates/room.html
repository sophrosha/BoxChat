{% extends "base.html" %}
{% block content %}

<style>
    .rooms-list { flex-direction: column; }
    .channel-item { position: relative; padding: 8px 12px; border-radius: var(--radius-sm); cursor: pointer; transition: 0.15s; margin: 2px 8px; display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .channel-item:hover { background-color: var(--bg-surface); }
    .channel-item.active { background-color: var(--bg-surface); color: var(--primary); }
    /* hide legacy hover action buttons; actions are moved to context menu */
    .channel-item:hover .channel-actions { display: none !important; }
    .channel-actions { display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); gap: 4px; }
    .channel-actions button { background: var(--danger); padding: 4px 8px; font-size: 0.75em; border: none; border-radius: var(--radius-sm); cursor: pointer; color: white; }
    .channel-icon { width: 18px; height: 18px; display: inline-block; vertical-align: middle; margin-right: 6px; }
    .unread-badge { background: #ff5c5c; color: white; border-radius: 50%; min-width: 22px; height: 22px; display: inline-flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700; flex-shrink: 0; line-height: 1; }
    
    .message-file { background: var(--bg-panel); padding: 12px; border-radius: var(--radius-md); margin: 8px 0; display: inline-flex; align-items: center; gap: 12px; border: 1px solid var(--border); }
    .message-image { max-width: 400px; max-height: 400px; border-radius: var(--radius-md); cursor: pointer; margin: 8px 0; display: block; }
    .message-audio { width: 100%; max-width: 400px; margin: 8px 0; }
    .file-icon { font-size: 1.8em; }
    
    .fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 10000; display: none; align-items: center; justify-content: center; cursor: pointer; }
    .fullscreen-overlay img { max-width: 90%; max-height: 90%; }
    
    .profile-preview { position: fixed; background: var(--bg-surface); padding: 20px; border-radius: var(--radius-lg); z-index: 10001; display: none; max-width: 380px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); border: 1px solid var(--border); }
    .avatar-clickable { cursor: pointer; }
    
    .file-preview-item { background: var(--bg-panel); padding: 10px; border-radius: var(--radius-md); position: relative; max-width: 180px; border: 1px solid var(--border); }
    .file-preview-item img { max-width: 100%; height: auto; border-radius: var(--radius-sm); display: block; }
    .file-preview-item .remove-btn { position: absolute; top: 5px; right: 5px; background: var(--danger); border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; color: white; font-size: 12px; }
    .file-preview-item .file-name { font-size: 0.8em; color: var(--text-muted); margin-top: 5px; word-break: break-all; }
    
    .msg-text { white-space: pre-wrap; word-wrap: break-word; line-height: 1.5; }

    /* Reply (quoted) block inside messages */
    .msg-reply {
        border-left: 3px solid rgba(0,0,0,0.08);
        background: rgba(0,0,0,0.03);
        padding: 8px 10px;
        margin-bottom: 8px;
        border-radius: 6px;
        font-size: 0.9rem;
        color: var(--text-muted);
        cursor: pointer;
        overflow: hidden;
    }
    .msg-reply:hover { background: rgba(0,0,0,0.05); }
    .msg-reply .reply-author { font-weight: 700; margin-bottom: 4px; color: var(--text-main); }
    .msg-reply .reply-snippet { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-muted); }
    .reply-target-highlight { box-shadow: 0 0 0 3px rgba(66,133,244,0.15) inset; transition: box-shadow 0.25s ease; }
    
    .message-reactions { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    .reaction { display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; background: var(--bg-panel); border-radius: 16px; cursor: pointer; font-size: 0.9em; border: 1px solid var(--border); transition: 0.15s; }
    .reaction:hover { background: var(--bg-surface); border-color: var(--primary); }
    .reaction.active { background: var(--primary); border-color: var(--primary); color: var(--bg-dark); }
    .reaction-emoji { font-size: 1em; }
    .reaction-count { font-size: 0.85em; }
    .reaction.active .reaction-count { color: var(--bg-dark); font-weight: 600; }
    
    .emoji-picker { position: fixed; background: var(--bg-surface); border-radius: var(--radius-lg); padding: 12px; width: 320px; max-height: 320px; overflow-y: auto; box-shadow: 0 8px 16px rgba(0,0,0,0.3); z-index: 10005; display: none; border: 1px solid var(--border); }
    .emoji-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; }
    .emoji-item { font-size: 1.4em; cursor: pointer; padding: 6px; text-align: center; border-radius: var(--radius-sm); transition: 0.1s; }
    .emoji-item:hover { background: var(--bg-panel); }
    
    .sticker-picker { position: fixed; background: var(--bg-surface); border-radius: var(--radius-lg); padding: 12px; width: 360px; max-height: 420px; overflow-y: auto; box-shadow: 0 8px 16px rgba(0,0,0,0.3); z-index: 10005; display: none; border: 1px solid var(--border); }
    .sticker-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .sticker-item { cursor: pointer; border-radius: var(--radius-md); overflow: hidden; transition: 0.15s; }
    .sticker-item img { width: 100%; height: auto; display: block; }
    .sticker-item:hover { transform: scale(1.05); }
    .message-sticker { max-width: 200px; max-height: 200px; cursor: pointer; border-radius: var(--radius-md); }
    
    .channel-section-title { font-size: 0.75rem; text-transform: uppercase; margin: 14px 0 6px 14px; color: var(--text-muted); font-weight: 700; letter-spacing: 0.5px; }
    .members-section { margin-top: 16px; padding-top: 14px; border-top: 1px solid var(--border); }
    .member-item { padding: 6px 12px; font-size: 0.9rem; color: var(--text-main); overflow: hidden; text-overflow: ellipsis; }
    .member-item.owner, .member-item.admin { color: var(--primary); font-weight: 600; }
</style>

<div class="rooms-list">
    <div class="rooms-header">
        {% if room.type == 'dm' %}
            <div style="padding: 12px 16px; font-weight: 600; font-size: 1rem;">
                {% for m in room.members %}
                    {% if m.user_id != current_user.id %}
                        {{ m.user.username }}
                    {% endif %}
                {% endfor %}
            </div>
        {% else %}
            <div style="padding: 12px 16px; font-weight: 600; font-size: 0.95rem; color: var(--text-main);">
                {{ room.name }}
            </div>
            <button id="roomsClose" class="rooms-close" title="Close channels" aria-label="Close channels" style="display:none;">‚úï</button>
            {% if member.role in ['owner', 'admin'] %}
            <div style="padding: 0 16px 12px; display: flex; gap: 8px;">
                <button onclick="inviteToRoom({{ room.id }}); return false;" style="flex: 1; background: var(--primary); color: var(--bg-dark); border: none; padding: 8px 12px; border-radius: var(--radius-sm); cursor: pointer; font-size: 0.85em; font-weight: 600;">üë• Invite</button>
                <a href="{{ url_for('api.room_settings', room_id=room.id) }}" style="flex: 0 0 auto; padding: 8px 12px; background: var(--bg-surface); color: var(--text-main); border: 1px solid var(--border); border-radius: var(--radius-sm); text-decoration: none; font-size: 0.85em; display: flex; align-items: center; justify-content: center;">‚öôÔ∏è</a>
            </div>
            {% endif %}
        {% endif %}
    </div>
    <div class="rooms-scroll-area" style="padding-top: 0;">
        {% if room.type != 'dm' %}
            <div class="channel-section-title">Channels</div>
            {% for ch in room.channels %}
                <div class="channel-item {% if ch.id == active_channel_id %}active{% endif %}" data-channel-id="{{ ch.id }}" data-channel-name="{{ ch.name }}" data-channel-description="{{ ch.description or '' }}" data-channel-emoji="{{ ch.icon_emoji or '' }}" data-channel-icon-url="{{ ch.icon_image_url or '' }}" onclick="goToChannel({{ ch.id }}, '{{ url_for('main.view_room', room_id=room.id, channel_id='__CH__') }}'.replace('__CH__', {{ ch.id }})); return false;" oncontextmenu="showChannelContextMenu(event, {{ ch.id }}); return false;">
                    {% if ch.icon_image_url %}
                        <img src="{{ ch.icon_image_url }}" class="channel-icon" style="width: 16px; height: 16px; border-radius: 2px;">
                    {% elif ch.icon_emoji %}
                        <span class="channel-icon" style="font-size: 14px;">{{ ch.icon_emoji }}</span>
                    {% else %}
                        <span class="channel-icon" style="font-size: 14px;">#</span>
                    {% endif %}
                    <span style="flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">{{ ch.name }}</span>
                    {% set cu = channel_unread_counts.get(ch.id) if channel_unread_counts is defined else 0 %}
                    {% if cu and cu > 0 %}<span class="unread-badge">{{ cu }}</span>{% endif %}
                    {% if member.role in ['owner', 'admin'] %}
                    <div class="channel-actions">
                        <button onclick="event.stopPropagation(); editChannel({{ ch.id }}, '{{ ch.name }}', '{{ ch.description or '' }}', '{{ ch.icon_emoji or '' }}', '{{ ch.icon_image_url or '' }}'); return false;" style="background: transparent; border: none; color: var(--text-muted); cursor: pointer; font-size: 1.2em;" title="Edit">
                            <span class="material-icons-round" style="font-size: 20px;">edit</span>
                        </button>
                        <button onclick="event.stopPropagation(); deleteChannel({{ ch.id }}); return false;" style="background: transparent; border: none; color: var(--danger); cursor: pointer; font-size: 1.2em;" title="Delete">
                            <span class="material-icons-round" style="font-size: 20px;">delete</span>
                        </button>
                    </div>
                    {% endif %}
                </div>
                {% if ch.description %}
                    <div style="font-size: 0.75em; color: var(--text-muted); margin: 2px 20px 8px; font-weight: 400;">{{ ch.description }}</div>
                {% endif %}
            {% endfor %}
            
            {% if member.role in ['owner', 'admin'] %}
            <form action="{{ url_for('api.add_channel', room_id=room.id) }}" method="POST" style="padding: 8px 12px; margin-top: 8px;">
                <input name="name" placeholder="+ New channel" class="custom-input" style="padding: 8px 12px; font-size: 0.85em;">
            </form>
            {% endif %}
        {% else %}
            <div style="padding: 14px; text-align: center; color: var(--text-muted); font-size: 0.9rem;">Direct message</div>
        {% endif %}
        
        <div class="members-section">
            <div class="channel-section-title">Members</div>
            {% for m in room.members %}
                <div class="member-item {% if m.role == 'owner' %}owner{% elif m.role == 'admin' %}admin{% endif %}" data-member-user-id="{{ m.user.id }}">
                    {% set p = m.user.presence_status if m.user is not none else 'offline' %}
                    {% if p == 'online' %}
                        <span class="status-dot" data-user-id="{{ m.user.id }}" style="width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px;background:#43b581;"></span>
                    {% elif p == 'away' %}
                        <span class="status-dot" data-user-id="{{ m.user.id }}" style="width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px;background:#faa61a;"></span>
                    {% else %}
                        <span class="status-dot" data-user-id="{{ m.user.id }}" style="width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px;background:#6b6b6b;opacity:1;"></span>
                    {% endif %}
                    {{ m.user.username }}
                </div>
            {% endfor %}
        </div>
    </div>
</div>

<div class="chat-area">
    <div class="chat-header">
        <button class="rooms-toggle" id="roomsToggle" title="Channels" aria-label="Toggle channels" style="display:none;">
            <span class="material-icons-round">menu</span>
        </button>
        <span style="font-size: 1rem; font-weight: 600; display: flex; align-items: center; gap: 8px;">
            {% if room.type == 'broadcast' %}üì¢{% else %}#{% endif %}
            {% if active_channel %}
                {{ active_channel.name }}
            {% else %}
                Chat
            {% endif %}
        </span>
        {% if room.type != 'dm' and member.role in ['owner', 'admin'] and active_channel %}
        <div style="display: flex; gap: 6px;">
            <button onclick="editChannel({{ active_channel.id }}, '{{ active_channel.name }}', '{{ active_channel.description or '' }}', '{{ active_channel.icon_emoji or '' }}', '{{ active_channel.icon_image_url or '' }}'); return false;" style="background: var(--bg-surface); border: 1px solid var(--border); color: var(--text-main); padding: 6px 12px; border-radius: var(--radius-sm); cursor: pointer; display: flex; align-items: center; gap: 4px;">
                <span class="material-icons-round" style="font-size: 20px;">edit</span>
            </button>
        </div>
        {% endif %}
    </div>
    
    <div class="messages-container" id="messages">
        {% for msg in messages %}
        <div class="message {% if msg.user_id == current_user.id %}sent{% else %}received{% endif %}" data-msg-id="{{ msg.id }}">
            {% if msg.user_id != current_user.id %}
            <div class="avatar avatar-clickable" onclick="showProfile({{ msg.user.id }}, event)">
                {% if msg.user.avatar_url and msg.user.avatar_url != "https://via.placeholder.com/50" %}
                <img src="{{ msg.user.avatar_url }}">
                {% else %}
                <div style="width: 100%; height: 100%; border-radius: 50%; background: var(--bg-panel); display: flex; align-items: center; justify-content: center;">
                    <span class="material-icons-round" style="font-size: 24px; color: var(--text-muted);">person</span>
                </div>
                {% endif %}
            </div>
            {% endif %}
            <div class="message-content" data-user-id="{{ msg.user_id }}">
                {% if msg.user_id != current_user.id %}
                <div class="msg-meta">
                    <span class="msg-author" onclick="showProfile({{ msg.user.id }}, event)">{{ msg.user.username }}</span>
                    <span class="msg-time" data-timestamp="{{ msg.timestamp.strftime('%Y-%m-%dT%H:%M:%SZ') }}"></span>
                </div>
                {% else %}
                <div class="msg-time" data-timestamp="{{ msg.timestamp.strftime('%Y-%m-%dT%H:%M:%SZ') }}"></div>
                {% endif %}
                
                <div class="msg-bubble">
                    {% if msg.message_type == 'sticker' %}
                        <img src="{{ msg.file_url }}" class="message-sticker" onclick="showFullscreen('{{ msg.file_url }}')">
                    {% elif msg.message_type == 'image' %}
                        <img src="{{ msg.file_url }}" class="message-image" onclick="showFullscreen('{{ msg.file_url }}')">
                        {% if msg.reply_to %}
                            <div class="msg-reply" data-reply-id="{{ msg.reply_to.id }}">
                                <div class="reply-author">{{ msg.reply_to.username }}</div>
                                <div class="reply-snippet">{{ msg.reply_to.snippet }}</div>
                            </div>
                        {% endif %}
                        {% if msg.content %}
                            <div class="msg-text" style="margin-top: 8px;">{{ msg.content|e }}</div>
                        {% endif %}
                    {% elif msg.message_type == 'music' %}
                        <div>
                            <div class="custom-media-player" data-type="audio">
                                <audio class="cmp-media" preload="metadata">
                                    <source src="{{ msg.file_url }}" type="audio/mpeg">
                                </audio>
                                <div class="cmp-controls">
                                    <button class="cmp-play" aria-label="Play">‚ñ∂</button>
                                    <div class="cmp-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                                        <div class="cmp-progress-filled"></div>
                                    </div>
                                    <div class="cmp-time">0:00 / 0:00</div>
                                    <div class="cmp-volume-wrap">
                                        <input type="range" class="cmp-volume" min="0" max="1" step="0.01" value="1" aria-label="Volume">
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 6px; font-size: 0.9rem; font-weight: 500; color: var(--text-main);">
                                {{ msg.file_name.rsplit('.', 1)[0] if msg.file_name else msg.file_url.split('/')[-1].rsplit('.', 1)[0] }}
                            </div>
                            <div style="margin-top: 8px; display: flex; gap: 8px; font-size: 0.9rem;">
                                <a href="{{ msg.file_url }}" download style="color: {% if msg.user_id == current_user.id %}var(--bg-dark){% else %}var(--primary){% endif %}; font-weight: 600;">Download</a>
                            </div>
                            {% if msg.content %}
                                {% if msg.reply_to %}
                                    <div class="msg-reply" data-reply-id="{{ msg.reply_to.id }}">
                                        <div class="reply-author">{{ msg.reply_to.username }}</div>
                                        <div class="reply-snippet">{{ msg.reply_to.snippet }}</div>
                                    </div>
                                {% endif %}
                                <div class="msg-text" style="margin-top: 8px;">{{ msg.content|e }}</div>
                            {% endif %}
                        </div>
                    {% elif msg.message_type == 'video' %}
                        <div>
                            <div class="custom-media-player video-player" data-type="video">
                                <video class="cmp-media" preload="metadata" playsinline>
                                    <source src="{{ msg.file_url }}" type="video/mp4">
                                </video>
                                <div class="cmp-controls">
                                    <button class="cmp-play" aria-label="Play">‚ñ∂</button>
                                    <div class="cmp-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                                        <div class="cmp-progress-filled"></div>
                                    </div>
                                    <div class="cmp-time">0:00 / 0:00</div>
                                    <div class="cmp-volume-wrap">
                                        <input type="range" class="cmp-volume" min="0" max="1" step="0.01" value="1" aria-label="Volume">
                                    </div>
                                    <button class="cmp-fullscreen" aria-label="Fullscreen">‚§¢</button>
                                </div>
                            </div>
                            {% if msg.content %}
                                {% if msg.reply_to %}
                                    <div class="msg-reply" data-reply-id="{{ msg.reply_to.id }}">
                                        <div class="reply-author">{{ msg.reply_to.username }}</div>
                                        <div class="reply-snippet">{{ msg.reply_to.snippet }}</div>
                                    </div>
                                {% endif %}
                                <div class="msg-text" style="margin-top: 8px;">{{ msg.content|e }}</div>
                            {% endif %}
                        </div>

                    {% elif msg.message_type == 'file' %}
                        <div style="display: flex; align-items: center; gap: 10px; min-width: 200px;">
                            <div class="file-icon">üìÑ</div>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; margin-bottom: 4px;">{{ msg.file_name }}</div>
                                <div style="font-size: 0.85rem; display: flex; gap: 12px;">
                                    <a href="{{ msg.file_url }}" onclick="previewFile('{{ msg.file_url }}'); return false;" style="color: {% if msg.user_id == current_user.id %}var(--bg-dark){% else %}var(--primary){% endif %}; text-decoration: underline;">Preview</a>
                                    <a href="{{ msg.file_url }}" download style="color: {% if msg.user_id == current_user.id %}var(--bg-dark){% else %}var(--primary){% endif %}; text-decoration: underline;">Download</a>
                                </div>
                            </div>
                        </div>
                        {% if msg.content %}
                            {% if msg.reply_to %}
                                <div class="msg-reply" data-reply-id="{{ msg.reply_to.id }}">
                                    <div class="reply-author">{{ msg.reply_to.username }}</div>
                                    <div class="reply-snippet">{{ msg.reply_to.snippet }}</div>
                                </div>
                            {% endif %}
                            <div class="msg-text" style="margin-top: 8px;">{{ msg.content|e }}</div>
                        {% endif %}
                    {% else %}
                        {% if msg.reply_to %}
                            <div class="msg-reply" data-reply-id="{{ msg.reply_to.id }}">
                                <div class="reply-author">{{ msg.reply_to.username }}</div>
                                <div class="reply-snippet">{{ msg.reply_to.snippet }}</div>
                            </div>
                        {% endif %}
                        <div class="msg-text">{{ msg.content|e }}</div>
                    {% endif %}
                </div>
                {% if msg.edited_at %}
                <span class="msg-edited" data-edited-at="{{ msg.edited_at.strftime('%Y-%m-%dT%H:%M:%SZ') }}" style="color: var(--text-muted); font-size: 0.75rem; align-self: center;">(edited)</span>
                {% endif %}
                
                {% if msg.reactions_grouped %}
                <div class="message-reactions">
                    {% for emoji, users in msg.reactions_grouped.items() %}
                    <div class="reaction {% if current_user.username in users %}active{% endif %}" onclick="toggleReaction({{ msg.id }}, '{{ emoji }}')">
                        <span class="reaction-emoji">{{ emoji }}</span>
                        <span class="reaction-count">{{ users|length }}</span>
                    </div>
                    {% endfor %}
                </div>
                {% endif %}
            </div>
        </div>
        {% endfor %}
    </div>

    <!-- Floating Jump-to-Latest Button (FAB) -->
    <!-- button id="jumpToLatestFAB" title="Jump to latest messages" style="position: fixed; bottom: 120px; right: 20px; width: 50px; height: 50px; border-radius: 50%; background: var(--primary); color: var(--bg-dark); border: none; font-size: 1.5rem; cursor: pointer; display: none; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 100; transition: 0.2s;\">‚Üì</button-->

    {% if room.type == 'broadcast' and member.role not in ['owner', 'admin'] %}
        <div class="chat-input-area" style="text-align: center; color: var(--text-muted); padding: 20px;">
            Only administrators can write here.
            {% if room.linked_chat_id %}
            <br><a href="{{ url_for('main.view_room', room_id=room.linked_chat_id) }}" style="color: var(--primary); font-weight: 600;">Go to comments</a>
            {% endif %}
        </div>
    {% else %}
        <div id="filePreviewArea" style="display: none; padding: 12px 20px; background: var(--bg-panel); border-top: 1px solid var(--border); max-height: 180px; overflow-y: auto;">
            <div id="filePreviews" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
        </div>
        <!-- Reply preview (shows quoted message when replying) -->
        <div id="replyPreview" style="display: none; padding: 8px 20px; background: rgba(0,0,0,0.03); border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);">
            <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                <div id="replyPreviewContent" style="font-size:0.9rem; color:var(--text-muted);"></div>
                <button type="button" class="btn btn-secondary" onclick="clearReply()">Cancel</button>
            </div>
        </div>
        <div class="chat-input-area">
            <input type="file" id="fileInput" style="display: none;" multiple accept="image/*,audio/*,.txt,.py,.js,.html,.css,.json,.xml,.md,.pdf,.zip,.rar">
            <button type="button" class="btn-icon btn-add" onclick="document.getElementById('fileInput').click();" title="Attach file">
                <span class="material-icons-round">attach_file</span>
            </button>
            <button type="button" class="btn-icon btn-add" onclick="toggleStickerPicker()" title="Emoji & stickers">
                <span class="material-icons-round">emoji_emotions</span>
            </button>
            <textarea id="myMessage" class="chat-input" placeholder="Type a message..." rows="1"></textarea>
            <button type="button" class="btn-icon btn-send" onclick="sendMessage()" title="Send message">
                <span class="material-icons-round">send</span>
            </button>
        </div>
    {% endif %}
</div>

<script>
// Mobile rooms list toggle: show/hide overlay and prevent background scrolling when open
function toggleRoomsMobile() {
    const rooms = document.querySelector('.rooms-list');
    if (!rooms) return;
    const isOpen = document.body.classList.contains('rooms-open');
    if (!isOpen) {
        // open overlay via body class, create backdrop
        document.body.classList.add('rooms-open');
        let backdrop = document.querySelector('.rooms-backdrop');
        if (!backdrop) {
            backdrop = document.createElement('div');
            backdrop.className = 'rooms-backdrop';
            document.body.appendChild(backdrop);
            backdrop.addEventListener('click', function() {
                document.body.classList.remove('rooms-open');
                const b = document.querySelector('.rooms-backdrop');
                if (b) b.remove();
            });
        }
    } else {
        // close overlay
        document.body.classList.remove('rooms-open');
        const backdrop = document.querySelector('.rooms-backdrop');
        if (backdrop) backdrop.remove();
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const btn = document.getElementById('roomsToggle');
    const rooms = document.querySelector('.rooms-list');
    if (!btn || !rooms) return;

    // Show the toggle button on small screens
    const mq = window.matchMedia('(max-width: 480px)');
    function updateToggleVisibility() {
        if (mq.matches) {
            btn.style.display = 'inline-flex';
            // hide the close button by default; CSS will show it when overlay is open
            const close = document.getElementById('roomsClose');
            if (close) close.style.display = 'none';
        } else {
            btn.style.display = 'none';
            document.body.classList.remove('rooms-open');
            const close = document.getElementById('roomsClose');
            if (close) close.style.display = 'none';
        }
    }
    mq.addListener(updateToggleVisibility);
    updateToggleVisibility();

    btn.addEventListener('click', function(e) {
        e.stopPropagation();
        toggleRoomsMobile();
    });

    // Clicking outside the rooms list closes it
    document.addEventListener('click', function(e) {
        if (!mq.matches) return;
        if (!document.body.classList.contains('rooms-open')) return;
        const target = e.target;
        if (!rooms.contains(target) && !btn.contains(target)) {
            document.body.classList.remove('rooms-open');
            const backdrop = document.querySelector('.rooms-backdrop');
            if (backdrop) backdrop.remove();
        }
    });
    // Close button inside rooms header
    const closeBtn = document.getElementById('roomsClose');
    if (closeBtn) {
        closeBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            document.body.classList.remove('rooms-open');
            const backdrop = document.querySelector('.rooms-backdrop');
            if (backdrop) backdrop.remove();
        });
    }
});
</script>

<script>
// Ensure messages are scrolled into view when input focuses (helps on mobile keyboard)
document.addEventListener('DOMContentLoaded', function() {
    const input = document.getElementById('myMessage');
    const messages = document.getElementById('messages');
    if (!input || !messages) return;

    function scrollToBottom() {
        messages.scrollTop = messages.scrollHeight;
    }

    input.addEventListener('focusin', function() {
        // Scroll to bottom and lock position
        scrollToBottom();
        messages.classList.add('no-scroll');
        document.body.style.overflow = 'hidden';
    });

    input.addEventListener('focusout', function() {
        // Unlock scroll
        messages.classList.remove('no-scroll');
        document.body.style.overflow = '';
    });
});
</script>

<!-- Overlays & Modals -->
<div class="fullscreen-overlay" id="fullscreenOverlay" onclick="this.style.display='none';">
    <img id="fullscreenImage" src="">
</div>

<div class="profile-preview" id="profilePreview"></div>

<!-- Confirmation Modal -->
<div class="modal-overlay" id="confirmModal">
    <div class="modal">
        <div class="modal-header" id="confirmTitle">Confirm</div>
        <div class="modal-body" id="confirmMessage"></div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeConfirmModal(false)">Cancel</button>
            <button class="btn btn-login" id="confirmBtn" onclick="closeConfirmModal(true)" style="background: var(--danger);">Confirm</button>
        </div>
    </div>
</div>

<!-- Alert Modal -->
<div class="modal-overlay" id="alertModal">
    <div class="modal">
        <div class="modal-header">Alert</div>
        <div class="modal-body" id="alertMessage"></div>
        <div class="modal-footer">
            <button class="btn btn-login" onclick="closeAlertModal()">OK</button>
        </div>
    </div>
</div>

<!-- Context Menu for Messages -->
<div class="context-menu" id="messageContextMenu">
    <div class="context-menu-item" onclick="copyMessage()">
        <span>üìã</span> Copy
    </div>
    <div class="context-menu-item" onclick="replyToMessageFromMenu()">
        <span>‚Ü©Ô∏è</span> Reply
    </div>
    <div class="context-menu-item" onclick="editMessage()">
        <span>‚úèÔ∏è</span> Edit
    </div>
    <div class="context-menu-item" onclick="forwardMessage()">
        <span>‚û°Ô∏è</span> –ü–µ—Ä–µ—Å–ª–∞—Ç—å
    </div>
    <div class="context-menu-item" onclick="showReactionPicker()">
        <span>üòÄ</span> –î–æ–±–∞–≤–∏—Ç—å —Ä–µ–∞–∫—Ü–∏—é
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item danger" onclick="deleteMessageFromMenu()">
        <span>üóëÔ∏è</span> –£–¥–∞–ª–∏—Ç—å
    </div>
</div>

<!-- –≠–º–æ–¥–∑–∏ –ø–∏–∫–µ—Ä -->
<div class="emoji-picker" id="emojiPicker">
    <div class="emoji-grid" id="emojiGrid"></div>
</div>

<!-- Context Menu for Channels -->
<div class="context-menu" id="channelContextMenu" style="display:none;">
    <div class="context-menu-item" onclick="editChannelFromContext()">
        <span class="material-icons-round">edit</span> Edit Channel
    </div>
    <div class="context-menu-item danger" onclick="deleteChannelFromContext()">
        <span class="material-icons-round">delete</span> Delete Channel
    </div>
</div>

<!-- –°—Ç–∏–∫–µ—Ä –ø–∏–∫–µ—Ä (–∫–∞–∫ –≤ Telegram) -->
<div class="sticker-picker" id="stickerPicker" style="width: 400px;">
    <div id="stickerPackList" style="display: flex; gap: 5px; padding: 10px; border-bottom: 1px solid #202225; overflow-x: auto;">
        <!-- –°–ø–∏—Å–æ–∫ —Å—Ç–∏–∫–µ—Ä–ø–∞–∫–æ–≤ –±—É–¥–µ—Ç –∑–¥–µ—Å—å -->
    </div>
    <div class="sticker-grid" id="stickerGrid" style="padding: 10px;"></div>
</div>





<!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ -->
<div class="modal-overlay" id="channelEditModal">
    <div class="modal">
        <div class="modal-header">Edit Channel</div>
        <form id="channelEditForm" onsubmit="saveChannelEdit(event); return false;">
            <div class="modal-body">
                <input type="hidden" id="edit_channel_id">
                <div class="input-group">
                    <label class="input-label">Channel Name</label>
                    <input type="text" id="edit_channel_name" class="custom-input" required>
                </div>
                <div class="input-group">
                    <label class="input-label">Description</label>
                    <textarea id="edit_channel_description" class="custom-input" style="resize: vertical; min-height: 60px;"></textarea>
                </div>
                <div class="input-group">
                    <label class="input-label">Emoji (32x32 icon)</label>
                    <input type="text" id="edit_channel_emoji" class="custom-input" placeholder="üéµ">
                </div>
                <div class="input-group">
                    <label class="input-label">Upload Icon</label>
                    <input type="file" id="edit_channel_icon" accept="image/*" class="custom-input" style="padding: 8px; cursor: pointer;">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="document.getElementById('channelEditModal').style.display='none';">Cancel</button>
                <button type="submit" class="btn btn-login">Save</button>
            </div>
        </form>
    </div>
</div>

<!-- Load socket.io client from the server (Flask-SocketIO exposes it at /socket.io/socket.io.js). */ -->
<script src="/static/js/socket.io.js"></script>
<script>
// Fallback to CDN if server copy missing
if (typeof io === 'undefined') {
    var s = document.createElement('script');
    s.src = 'https://cdn.socket.io/4.6.1/socket.io.min.js';
    s.crossOrigin = 'anonymous';
    document.head.appendChild(s);
}
</script>
<script>
    // === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (–æ–±—ä—è–≤–ª—è—é—Ç—Å—è –¥–æ –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π) ===
    let selectedFiles = [];
    let filePreviews = [];
    let contextMenuMessageId = null;
    let contextMenuMessageElement = null;
    let contextMenuChannelId = null;
    let contextMenuChannelData = {};
    let confirmCallback = null;
    const commonEmojis = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üôè', 'üî•', 'üëè', 'üéâ', 'üíØ', 'üòç', 'ü§î', 'üò¥', 'ü§Æ', 'üí©'];

    // Known playable music extensions (keep synced with server config)
    const MUSIC_EXTENSIONS = ['mp3','ogg','flac','wav'];

    // Pause all other audio elements except the provided one
    function pauseAllOtherAudio(exceptEl) {
        document.querySelectorAll('audio').forEach(a => {
            try {
                if (exceptEl && a === exceptEl) return;
                a.pause();
            } catch (e) {}
        });
    }

    // Pause all other media (audio/video) except the specified one
    function pauseAllOtherMedia(exceptEl) {
        document.querySelectorAll('audio, video').forEach(m => {
            try {
                if (exceptEl && m === exceptEl) return;
                m.pause();
            } catch (e) {}
        });
    }

    // Global aliases so functions outside initializeApp can access socket and ids
    var socket = null;
    var channelId = null;
    var roomId = null;
    var messagesDiv = null;
    var currentUserId = null;
    var currentUsername = null;
    var userRole = null;
    var pendingReactions = {}; // store reactions received before message DOM exists

    // ========== JUMP TO LATEST FAB BUTTON ==========
    // Define setupJumpFAB BEFORE initializeApp so it's available when called
    window.setupJumpFAB = function() {
        const fabBtn = document.getElementById('jumpToLatestFAB');
        const md = window.messagesDiv || document.getElementById('messages');
        if (!fabBtn || !md) {
            console.warn('setupJumpFAB: fabBtn or messagesDiv not found', {fabBtn: !!fabBtn, messagesDiv: !!md});
            return;
        }

        // Remove old event listeners if they exist
        if (md._fabScrollListener) {
            md.removeEventListener('scroll', md._fabScrollListener);
        }

        const checkScrollPosition = function() {
            const isNearBottom = (md.scrollHeight - md.scrollTop - md.clientHeight) < 150;
            fabBtn.style.display = isNearBottom ? 'none' : 'flex';
        };

        // Store listener so we can clean it up
        md._fabScrollListener = checkScrollPosition;
        md.addEventListener('scroll', checkScrollPosition);
        
        // Wrap addMessageToChat to update FAB on new messages
        if (!window._addMessageToChat_original) {
            window._addMessageToChat_original = window.addMessageToChat;
            window.addMessageToChat = function(data) {
                window._addMessageToChat_original.call(window, data);
                setTimeout(checkScrollPosition, 100);
            };
        }

        // Click handler: scroll to bottom and mark as read
        if (!fabBtn._initialized) {
            fabBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                try {
                    md.scrollTop = md.scrollHeight;
                    fabBtn.style.display = 'none';
                    // Mark channel as read
                    if (window.channelId) {
                        fetch(`/channel/${window.channelId}/mark_read`, { method: 'POST' }).catch(e => {});
                    }
                } catch (e) { console.error('FAB click failed', e); }
            });
            fabBtn._initialized = true;
        }

        // Initial check
        checkScrollPosition();
        console.log('[DEBUG] setupJumpFAB initialized, messagesDiv ready:', !!md, 'isNearBottom:', (md.scrollHeight - md.scrollTop - md.clientHeight) < 150);
    };

    // === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ socket.io –ò DOM ===
    function initializeApp() {
        // Prevent double initialization
        if (window._roomAppInitialized) {
            console.debug('[initializeApp] Already initialized, skipping');
            return;
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –ª–∏ socket.io –±–∏–±–ª–∏–æ—Ç–µ–∫–∞
        if (typeof io === 'undefined') {
            // Try to dynamically load the CDN once, avoid spamming the console
            if (!window._socketIoLoadAttempted) {
                window._socketIoLoadAttempted = true;
                console.warn('socket.io not found; attempting dynamic load from CDN...');
                const s = document.createElement('script');
                s.src = 'https://cdn.socket.io/4.6.1/socket.io.min.js';
                s.crossOrigin = 'anonymous';
                s.onload = function() { console.info('socket.io loaded from CDN'); initializeApp(); };
                s.onerror = function() { console.error('Failed to load socket.io from CDN'); setTimeout(initializeApp, 1000); };
                document.head.appendChild(s);
                return;
            }
            // Already attempted loading; retry later but not too frequently
            setTimeout(initializeApp, 1000);
            return;
        }
        
        // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ socket.io –∏ —Å–ª—É—à–∞—Ç–µ–ª–µ–π
        socket = io();
        channelId = parseInt("{{ active_channel_id }}") || null;
        roomId = parseInt("{{ room.id }}") || null;
        messagesDiv = document.getElementById('messages');
        currentUserId = {{ current_user.id }};
        currentUsername = "{{ current_user.username }}";
        userRole = "{{ member.role }}";

        // Also expose on window for templates/scripts expecting window.*
        window.socket = socket;
        window.channelId = channelId;
        window.roomId = roomId;
        window.messagesDiv = messagesDiv;
        window.currentUserId = currentUserId;
        window.currentUsername = currentUsername;
        window.userRole = userRole;
        
        // Setup all socket listeners after socket is ready
        try { window.setupReactionsListener(); } catch (e) { console.error('setupReactionsListener failed', e); }
        try { window.setupMessageEditedListener(); } catch (e) { console.error('setupMessageEditedListener failed', e); }
        
        // Setup FAB button immediately after messagesDiv is assigned
        try { window.setupJumpFAB(); } catch (e) { console.error('setupJumpFAB after messagesDiv assignment failed', e); }
        
        // Reply state for reply-to-message feature
        // when set, sendMessage will include reply metadata and preview it
        window.replyTo = null; // { id, username, snippet }

        // Click on member to show profile (same as clicking on avatar)
        (function() {
            document.querySelectorAll('.member-item').forEach(function(el) {
                el.style.cursor = 'pointer';
                el.addEventListener('click', function(ev) {
                    const targetUserId = el.getAttribute('data-member-user-id');
                    if (!targetUserId) return;
                    ev.stopPropagation();
                    // Show same profile modal as clicking on avatar
                    showProfile(parseInt(targetUserId), ev);
                });
            });
        })();

        // Attach handler so playing one audio stops others (for existing audio elements)
        try {
            document.querySelectorAll('audio').forEach(a => {
                a.onplay = () => pauseAllOtherAudio(a);
            });
        } catch (e) {}

        // Load saved draft for this channel (if any)
        try {
            const inputEl = document.getElementById('myMessage');
            const draftKey = `draft_${roomId}_${channelId}`;
            const saved = localStorage.getItem(draftKey);
            if (saved && inputEl) inputEl.value = saved;
            if (inputEl) {
                inputEl.addEventListener('input', () => {
                    try { localStorage.setItem(draftKey, inputEl.value); } catch (e) {}
                });
            }
        } catch (e) {}
        
        // Setup socket listeners ONLY if not already attached
        if (!socket._roomListenersAttached) {
            socket._roomListenersAttached = true;
            console.debug('[socket] Attaching room listeners (connect, receive_message, etc)');
            
            socket.on('connect', function() {
                console.debug('[socket.connect] Connected, emitting join for channel:', channelId);
                socket.emit('join', {channel_id: channelId});
                
                // Update own status in the members list immediately
                console.log('[socket.connect] Looking for own status dot with userId:', window.currentUserId);
                const ownDot = document.querySelector(`.status-dot[data-user-id="${window.currentUserId}"]`);
                console.log('[socket.connect] Found ownDot:', ownDot);
                if (ownDot) {
                    console.log('[socket.connect] Updating own status to green');
                    // Connected = online
                    ownDot.style.background = '#43b581'; // green
                    ownDot.style.opacity = '1';
                } else {
                    console.warn('[socket.connect] Own status dot not found! Looking for all dots:', document.querySelectorAll('.status-dot'));
                }
            });

            socket.on('receive_message', function(data) {
                console.debug('[socket.receive_message] Got message from', data.username, ':', data.msg.substring(0, 50));
                try { console.debug('receive_message payload:', data); } catch(e) {}
                addMessageToChat(data);
            });

            socket.on('presence_updated', function(data) {
            try {
                if (!data || !data.user_id) return;
                const userId = Number(data.user_id);
                const dot = document.querySelector(`.status-dot[data-user-id="${userId}"]`);
                if (!dot) return;
                const status = data.status || 'offline';
                if (status === 'online') {
                    dot.style.background = '#43b581'; // green
                } else if (status === 'away') {
                    dot.style.background = '#faa61a'; // yellow
                } else if (status === 'hidden') {
                    dot.style.background = '#6b6b6b'; // muted
                    dot.style.opacity = '0.6';
                } else {
                    dot.style.background = '#6b6b6b';
                    dot.style.opacity = '1';
                }
            } catch (e) { console.error('presence_updated handler failed', e); }
        });

        socket.on('error', function(data) {
            try {
                if (data && data.message) showAlert(data.message);
            } catch (e) { console.error('Socket error event', data); }
        });

        socket.on('message_deleted', function(data) {
            const msgElement = document.querySelector(`[data-msg-id="${data.message_id}"]`);
            if (msgElement) {
                msgElement.remove();
            }
        });

            socket.on('member_removed', function(data) {
                try {
                    if (!data || !data.user_id) return;
                    const uid = String(data.user_id);
                    // remove member item from members list
                    const el = document.querySelector(`.member-item[data-member-user-id="${uid}"]`);
                    if (el) el.remove();
                } catch (e) { console.error('member_removed handler error', e); }
            });

            socket.on('bulk_messages_deleted', function(data) {
                try {
                    if (!data || !data.user_id) return;
                    const uid = String(data.user_id);
                    // remove all messages from this user in DOM
                    document.querySelectorAll('.message').forEach(function(m) {
                        const content = m.querySelector('.message-content');
                        if (content && content.getAttribute('data-user-id') == uid) {
                            m.remove();
                        }
                    });
                } catch (e) { console.error('bulk_messages_deleted handler error', e); }
            });

            socket.on('force_redirect', function(data) {
                try {
                    // This event is delivered to the specific user room; redirect immediately
                    const loc = (data && data.location) ? data.location : '/';
                    if (loc) {
                        // Immediately redirect without alert
                        window.location = loc;
                    }
                } catch (e) { console.error('force_redirect handler error', e); }
            });

        // Listen for notifications everywhere (not just dashboard)
        socket.on('message_notification', function(data) {
            console.debug('[socket.message_notification] Got notification from', data.from_user, 'channel:', data.channel_id, 'unread:', data.unread_count);
            try {
                const title = data.from_user || 'New message';
                const body = data.snippet || 'New message';
                if (window.Notification && Notification.permission === 'granted') {
                    try {
                        const n = new Notification(title, { body: body, icon: '/static/img/logo-192.png' });
                        n.onclick = function() {
                            window.focus();
                            // If the notification is for current channel, do nothing (user already sees it)
                            // Otherwise navigate to the channel
                            if (data.channel_id && data.channel_id !== window.channelId) {
                                window.location.href = '/room/' + data.room_id + '?channel_id=' + data.channel_id;
                            }
                        };
                    } catch (e) { console.error('Notification failed', e); }
                }
            } catch (e) { console.error('message_notification handler in room failed', e); }
            });
        } // End of socket listeners attachment
        
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                addFilePreview(file);
            });
            updateFilePreviewArea();
        });

        const textarea = document.getElementById('myMessage');
        if (textarea) {
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –≤—ã—Å–æ—Ç—ã textarea
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
            });

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ Tab –¥–ª—è –æ—Ç—Å—Ç—É–ø–∞
            textarea.addEventListener('keydown', function(event) {
                if (event.key === 'Tab') {
                    event.preventDefault();
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                    this.selectionStart = this.selectionEnd = start + 4;
                }
            });

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ Enter –∏ Shift+Enter
            textarea.addEventListener("keydown", function(event) {
                if (event.key === "Enter" && !event.shiftKey) {
                    event.preventDefault();
                    sendMessage();
                }
            });
        }

        // Paste from clipboard: support images and files (screenshots, copied files)
        document.addEventListener('paste', function(e) {
            try {
                const items = (e.clipboardData && e.clipboardData.items) || [];
                let handled = false;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        if (file) {
                            addFilePreview(file);
                            handled = true;
                        }
                    }
                }
                if (handled) {
                    updateFilePreviewArea();
                    e.preventDefault();
                }
            } catch (e) { console.error('paste handler error', e); }
        });
        
        // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        normalizeExistingMessages();
        renderTimestampsAndSeparators();
        // Bind click handlers to any server-rendered reply blocks so clicking jumps to target
        try {
            document.querySelectorAll('.msg-reply').forEach(rb => {
                if (!rb.dataset || !rb.dataset.replyId) return;
                rb.style.cursor = 'pointer';
                rb.addEventListener('click', function(e) {
                    e.stopPropagation();
                    try {
                        const target = document.querySelector(`[data-msg-id="${rb.dataset.replyId}"]`);
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            target.classList.add('reply-target-highlight');
                            setTimeout(() => target.classList.remove('reply-target-highlight'), 1400);
                        }
                    } catch (ex) { console.error('bindExistingReplyClicks jump failed', ex); }
                });
            });
        } catch (e) { console.error('bindExistingReplyClicks failed', e); }
        
        // –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –≤–Ω–∏–∑
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        
        // === –ö–û–ù–¢–ï–ö–°–¢–ù–û–ï –ú–ï–ù–Æ –ò –°–û–ë–´–¢–ò–Ø –î–û–ö–£–ú–ï–ù–¢–ê ===
        // Long-press handler for mobile
        let touchTimeout;
        let touchX, touchY;
        
        document.addEventListener('touchstart', function(e) {
            const messageEl = e.target.closest('.message');
            if (messageEl) {
                touchX = e.touches[0].clientX;
                touchY = e.touches[0].clientY;
                touchTimeout = setTimeout(() => {
                    e.preventDefault();
                    const msgId = messageEl.getAttribute('data-msg-id');
                    if (msgId) {
                        contextMenuMessageId = parseInt(msgId);
                        contextMenuMessageElement = messageEl;
                        showContextMenu(touchX, touchY);
                    }
                }, 500); // 500ms long-press
            }
        });
        
        document.addEventListener('touchend', function() {
            clearTimeout(touchTimeout);
        });
        
        document.addEventListener('touchmove', function() {
            clearTimeout(touchTimeout);
        });
        
        document.addEventListener('contextmenu', function(e) {
            const messageEl = e.target.closest('.message');
            if (messageEl) {
                e.preventDefault();
                const msgId = messageEl.getAttribute('data-msg-id');
                if (msgId) {
                    contextMenuMessageId = parseInt(msgId);
                    contextMenuMessageElement = messageEl;
                    showContextMenu(e.clientX, e.clientY);
                }
            }
        });

        document.addEventListener('click', function() {
            hideContextMenu();
        });
        
        document.getElementById('confirmModal').addEventListener('click', function(e) {
            if (e.target === this) closeConfirmModal(false);
        });
        document.getElementById('alertModal').addEventListener('click', function(e) {
            if (e.target === this) closeAlertModal();
        });
        
        document.addEventListener('click', function(e) {
            if (!e.target.closest('#profilePreview') && !e.target.closest('.avatar-clickable') && !e.target.closest('.msg-meta span')) {
                document.getElementById('profilePreview').style.display = 'none';
            }
        });
        
        // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ü–û–°–õ–ï –ó–ê–ì–†–£–ó–ö–ò ===
        // FAB button is already initialized after messagesDiv assignment
        
        // Mark as initialized to prevent double-initialization
        window._roomAppInitialized = true;
        console.log('[initializeApp] Initialization complete');
    }
    
    // Call initializeApp on document ready or immediately if already loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }
    function setupChannelLongPress() {
        const channelItems = document.querySelectorAll('.channel-item');
        channelItems.forEach(item => {
            let touchTimeout;
            let touchX, touchY;
            
            item.addEventListener('touchstart', function(e) {
                touchX = e.touches[0].clientX;
                touchY = e.touches[0].clientY;
                touchTimeout = setTimeout(() => {
                    const channelId = item.dataset.channelId;
                    if (channelId) {
                        // Create a synthetic event object with necessary properties
                        const syntheticEvent = {
                            preventDefault: () => {},
                            stopPropagation: () => {},
                            clientX: touchX,
                            clientY: touchY,
                            target: item
                        };
                        showChannelContextMenu(syntheticEvent, parseInt(channelId));
                    }
                }, 500); // 500ms long-press
            });
            
            item.addEventListener('touchend', function() {
                clearTimeout(touchTimeout);
            });
            
            item.addEventListener('touchmove', function() {
                clearTimeout(touchTimeout);
            });
        });
    }
    
    // Setup long-press for server icons in sidebar on mobile (prevent link preview)
    function setupServerLongPress() {
        const serverItems = document.querySelectorAll('.sidebar-server');
        serverItems.forEach(item => {
            let touchTimeout;
            let touchStarted = false;
            let touchX, touchY;
            
            item.addEventListener('touchstart', function(e) {
                touchStarted = true;
                touchX = e.touches[0].clientX;
                touchY = e.touches[0].clientY;
                e.preventDefault(); // Prevent link preview immediately
                touchTimeout = setTimeout(() => {
                    // Show context menu
                    const roomId = item.dataset.roomId;
                    const role = item.dataset.role;
                    if (roomId) {
                        window.sidebarContextMenuServerId = parseInt(roomId);
                        window.sidebarContextMenuServerRole = role;
                        
                        const menu = document.getElementById('sidebarServerContextMenu');
                        if (menu) {
                            menu.style.display = 'block';
                            menu.style.left = Math.min(touchX, window.innerWidth - 220) + 'px';
                            menu.style.top = Math.min(touchY, window.innerHeight - 200) + 'px';
                            
                            // Show/hide menu items based on role
                            const canInvite = role === 'owner' || role === 'admin';
                            const canDelete = role === 'owner' || role === 'admin';
                            const canLeave = role !== 'owner';
                            
                            const menuItems = menu.querySelectorAll('.context-menu-item');
                            if (menuItems[0]) menuItems[0].style.display = canInvite ? 'flex' : 'none';
                            if (menuItems[1]) menuItems[1].style.display = canDelete ? 'flex' : 'none';
                            if (menuItems[2]) menuItems[2].style.display = canLeave ? 'flex' : 'none';
                        }
                    }
                }, 500);
            }, { passive: false });
            
            item.addEventListener('touchend', function(e) {
                if (!touchStarted) return;
                clearTimeout(touchTimeout);
                touchStarted = false;
                // Navigate to the link
                window.location.href = item.href;
                e.preventDefault();
            }, { passive: false });
            
            item.addEventListener('touchmove', function() {
                clearTimeout(touchTimeout);
                touchStarted = false;
            });
        });
    }
    
    // –í—ã–∑—ã–≤–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –∫–æ–≥–¥–∞ DOM –≥–æ—Ç–æ–≤
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOMContentLoaded - calling initializeApp');
            initializeApp();
            // Initialize media players for server-rendered content
            setTimeout(() => {
                console.log('[DEBUG] DOMContentLoaded+0ms - initializing media players');
                runUpgradeAndInit();
            }, 50);
        });
    } else {
        console.log('[DEBUG] DOM already loaded - calling initializeApp immediately');
        initializeApp();
        // Initialize media players for server-rendered content
        setTimeout(() => {
            console.log('[DEBUG] DOM loaded+0ms - initializing media players');
            runUpgradeAndInit();
        }, 50);
    }
    
    // Setup channel long-press after DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupChannelLongPress);
        document.addEventListener('DOMContentLoaded', setupServerLongPress);
    } else {
        setupChannelLongPress();
        setupServerLongPress();
    }
    
    // === –§–£–ù–ö–¶–ò–ò (–æ–±—ä—è–≤–ª—è—é—Ç—Å—è –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º —Å–∫–æ–ø–µ, –¥–æ—Å—Ç—É–ø–Ω—ã –≤—Å–µ–≥–¥–∞) ===

    function addFilePreview(file) {
        const preview = {
            file: file,
            id: Date.now() + Math.random()
        };
        filePreviews.push(preview);
        renderFilePreviews();
    }

    function removeFilePreview(id) {
        filePreviews = filePreviews.filter(p => p.id !== id);
        renderFilePreviews();
        updateFilePreviewArea();
    }

    function renderFilePreviews() {
        const container = document.getElementById('filePreviews');
        container.innerHTML = '';
        
        filePreviews.forEach(preview => {
            const div = document.createElement('div');
            div.className = 'file-preview-item';
            div.dataset.previewId = preview.id;
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '√ó';
            removeBtn.onclick = () => removeFilePreview(preview.id);
            
            if (preview.file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.alt = preview.file.name;
                    img.style.maxWidth = '180px';
                    img.style.maxHeight = '180px';
                    img.style.borderRadius = '5px';
                    
                    const fileName = document.createElement('div');
                    fileName.className = 'file-name';
                    fileName.textContent = preview.file.name;
                    
                    div.appendChild(removeBtn);
                    div.appendChild(img);
                    div.appendChild(fileName);
                };
                reader.readAsDataURL(preview.file);
            } else if (preview.file.type.startsWith('audio/')) {
                const ext = (preview.file.name.split('.').pop() || '').toLowerCase();
                // If extension is not a known playable music ext, show generic file preview
                if (!MUSIC_EXTENSIONS.includes(ext)) {
                    const icon = document.createElement('div');
                    icon.className = 'file-icon';
                    icon.style.textAlign = 'center';
                    icon.style.fontSize = '2em';
                    icon.textContent = 'üéµ';

                    const fileName = document.createElement('div');
                    fileName.className = 'file-name';
                    fileName.textContent = preview.file.name;

                    div.appendChild(removeBtn);
                    div.appendChild(icon);
                    div.appendChild(fileName);
                } else {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const audio = document.createElement('audio');
                        audio.controls = true;
                        audio.style.width = '180px';
                        audio.style.height = '30px';
                        const source = document.createElement('source');
                        source.src = e.target.result;
                        source.type = preview.file.type;
                        audio.appendChild(source);
                        // stop other audio when this plays
                        audio.onplay = () => pauseAllOtherAudio(audio);

                        const fileName = document.createElement('div');
                        fileName.className = 'file-name';
                        fileName.textContent = preview.file.name;

                        div.appendChild(removeBtn);
                        div.appendChild(audio);
                        div.appendChild(fileName);
                    };
                    reader.readAsDataURL(preview.file);
                }
            } else {
                const ext = preview.file.name.split('.').pop().toUpperCase();
                const icon = document.createElement('div');
                icon.className = 'file-icon';
                icon.style.textAlign = 'center';
                icon.style.fontSize = '3em';
                icon.textContent = 'üìé';
                
                const fileName = document.createElement('div');
                fileName.className = 'file-name';
                fileName.textContent = preview.file.name;
                
                const extLabel = document.createElement('div');
                extLabel.style.fontSize = '0.7em';
                extLabel.style.color = '#72767d';
                extLabel.textContent = ext + ' —Ñ–∞–π–ª';
                
                div.appendChild(removeBtn);
                div.appendChild(icon);
                div.appendChild(fileName);
                div.appendChild(extLabel);
            }
            
            container.appendChild(div);
        });
    }

    function updateFilePreviewArea() {
        const area = document.getElementById('filePreviewArea');
        if (filePreviews.length > 0) {
            area.style.display = 'block';
        } else {
            area.style.display = 'none';
        }
    }

    function sendMessage() {
        // Prevent double-send by checking a flag
        if (window._messageSending) {
            console.debug('[sendMessage] Send already in progress, ignoring');
            return;
        }
        
        const input = document.getElementById('myMessage');
        let text = input.value;
        
        // –£–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—å–Ω—ã–µ –∏ –∫–æ–Ω–µ—á–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã/–ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫
        // –ü–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫ –≤–Ω—É—Ç—Ä–∏ —Ç–µ–∫—Å—Ç–∞ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è
        text = text.trim();
        
        if (filePreviews.length > 0) {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã —Å –æ–¥–Ω–∏–º —Ç–µ–∫—Å—Ç–æ–º
            window._messageSending = true;
            console.debug('[sendMessage] Sending', filePreviews.length, 'files with caption:', text);
            filePreviews.forEach(preview => {
                uploadAndSendFile(preview.file, text);
            });
            filePreviews = [];
            document.getElementById('fileInput').value = '';
            updateFilePreviewArea();
            input.value = '';
            input.style.height = 'auto';
            // Reset flag after a short delay to allow async operations
            setTimeout(() => { window._messageSending = false; }, 500);
        } else if (text) {
            window._messageSending = true;
            console.debug('[sendMessage] Sending text message:', text.substring(0, 50));
            const payload = {
                room_id: Number(window.roomId),
                channel_id: Number(window.channelId),
                msg: text,
                message_type: 'text'
            };
            if (window.replyTo) {
                payload.reply_to = { id: window.replyTo.id, username: window.replyTo.username, snippet: window.replyTo.snippet };
            }
            window.socket.emit('send_message', payload);
            input.value = '';
            input.style.height = 'auto';
            // clear reply state after sending
            clearReply();
            // Reset flag
            setTimeout(() => { window._messageSending = false; }, 500);
        }
    }

    function uploadAndSendFile(file, caption) {
        const formData = new FormData();
        formData.append('file', file);
        
        fetch('/upload_file', {
            method: 'POST',
            body: formData,
            credentials: 'same-origin',
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(r => {
            if (!r.ok) {
                console.error('Upload error:', r.status, r.statusText);
                return null;
            }
            return r.json().catch(e => {
                console.error('JSON parse error:', e);
                return null;
            });
        })
        .then(data => {
            if (data && data.success) {
                const messageType = data.type;
                const payload = {
                    room_id: Number(window.roomId),
                    channel_id: Number(window.channelId),
                    msg: caption || '',
                    message_type: messageType,
                    file_url: data.url,
                    file_name: data.filename || file.name,
                    file_size: file.size
                };
                if (window.replyTo) payload.reply_to = { id: window.replyTo.id, username: window.replyTo.username, snippet: window.replyTo.snippet };
                window.socket.emit('send_message', payload);
            } else if (data === null) {
                console.error('Upload failed or invalid response');
            }
        })
        .catch(err => console.error('Upload error:', err));
    }

    function deleteMessage(messageId) {
        showConfirm('–£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ', '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ?', () => {
            fetch(`/message/${messageId}/delete`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const msgElement = document.querySelector(`[data-msg-id="${messageId}"]`);
                    if (msgElement) {
                        msgElement.remove();
                    }
                } else {
                    showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
                }
            });
        });
    }

    function addMessageToChat(data) {
        try { console.debug('addMessageToChat called, reply_to present:', !!data.reply_to, data.reply_to); } catch(e) {}
        const div = document.createElement('div');
        div.className = 'message';
        div.setAttribute('data-msg-id', data.id || '');
        // Determine if we should auto-scroll after adding (only when user is near bottom)
        // Ensure messagesDiv is initialized
        if (!window.messagesDiv) {
            window.messagesDiv = document.getElementById('messages') || document.querySelector('.messages-container');
        }
        
        let wasNearBottom = true;
        try {
            if (window.messagesDiv) {
                wasNearBottom = (window.messagesDiv.scrollHeight - window.messagesDiv.scrollTop - window.messagesDiv.clientHeight) < 150;
            }
        } catch (e) { wasNearBottom = true; }
        
        // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å–æ–æ–±—â–µ–Ω–∏—è, —Ä–∞–∑–ª–∏—á–∞—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
        const isSent = Number(data.user_id) === Number(window.currentUserId);
        div.className = 'message ' + (isSent ? 'sent' : 'received');

        if (!isSent) {
            // received message: show avatar then content, match server-rendered markup (.msg-bubble)
            div.innerHTML = `
                <div class="avatar avatar-clickable" onclick="showProfile(${data.user_id || 0}, event)">
                    <img src="${data.avatar}">
                </div>
                <div class="message-content" data-user-id="${data.user_id || 0}">
                    <div class="msg-meta">
                        <span class="msg-author" onclick="showProfile(${data.user_id || 0}, event)">${data.username}</span>
                        <span class="msg-time" data-timestamp="${data.timestamp_iso || data.timestamp || ''}"></span>
                        ${data.edited_at_iso ? `<span class=\"msg-edited\" data-edited-at=\"${data.edited_at_iso}\" style=\"color: #72767d; font-size: 0.85em; margin-left: 5px;\">(–∏–∑–º–µ–Ω–µ–Ω–æ)</span>` : ''}
                    </div>
                    <div class="msg-bubble"><div class="msg-text"></div></div>
                </div>
            `;
        } else {
            // sent message: content first (aligned to right), no avatar and no author label
            div.innerHTML = `
                <div class="message-content" data-user-id="${data.user_id || 0}">
                    <div class="msg-meta">
                        <span class="msg-time" data-timestamp="${data.timestamp_iso || data.timestamp || ''}"></span>
                        ${data.edited_at_iso ? `<span class=\"msg-edited\" data-edited-at=\"${data.edited_at_iso}\" style=\"color: #72767d; font-size: 0.85em; margin-left: 5px;\">(–∏–∑–º–µ–Ω–µ–Ω–æ)</span>` : ''}
                    </div>
                    <div class="msg-bubble"><div class="msg-text"></div></div>
                </div>
            `;
        }

        const msgTextDiv = div.querySelector('.msg-text');

        // If this message is a reply to another message, render a small quoted block
        if (data.reply_to) {
            try {
                const rt = data.reply_to;
                const replyBlock = document.createElement('div');
                replyBlock.className = 'msg-reply';
                replyBlock.setAttribute('data-reply-id', rt.id || '');

                const author = document.createElement('div');
                author.className = 'reply-author';
                author.textContent = rt.username || 'Unknown';

                const snippet = document.createElement('div');
                snippet.className = 'reply-snippet';
                snippet.textContent = rt.snippet || '';

                replyBlock.appendChild(author);
                replyBlock.appendChild(snippet);

                // If original message id provided, allow jump-to-message on click
                if (rt.id) {
                    replyBlock.style.cursor = 'pointer';
                    replyBlock.addEventListener('click', function (e) {
                        e.stopPropagation();
                        try {
                            const target = document.querySelector(`[data-msg-id="${rt.id}"]`);
                            if (target) {
                                target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                target.classList.add('reply-target-highlight');
                                setTimeout(() => target.classList.remove('reply-target-highlight'), 1400);
                            }
                        } catch (ex) { console.error('Jump to reply target failed', ex); }
                    });
                }

                // Insert reply block above the message text so setting textContent doesn't remove it
                try {
                    const bubble = div.querySelector('.msg-bubble') || div.querySelector('.message-content');
                    if (bubble && msgTextDiv) {
                        bubble.insertBefore(replyBlock, msgTextDiv);
                    } else {
                        msgTextDiv.appendChild(replyBlock);
                    }
                } catch (e) {
                    try { msgTextDiv.appendChild(replyBlock); } catch (ex) { console.error('append replyBlock fallback failed', ex); }
                }
            } catch (e) { console.error('Render reply failed', e); }
        }
        
        // Helper to escape HTML when rendering text
        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
                if (data.message_type === 'sticker') {
            const img = document.createElement('img');
            img.src = data.file_url;
            img.className = 'message-sticker';
            img.onclick = () => showFullscreen(data.file_url);
            msgTextDiv.appendChild(img);
        } else if (data.message_type === 'image') {
            const img = document.createElement('img');
            img.src = data.file_url;
            img.className = 'message-image';
            img.onclick = () => showFullscreen(data.file_url);
            msgTextDiv.appendChild(img);
            if (data.msg) {
                const textDiv = document.createElement('div');
                textDiv.className = 'msg-text';
                // preserve newlines by setting text content; CSS `pre-wrap` will render them
                textDiv.textContent = data.msg || '';
                msgTextDiv.appendChild(textDiv);
            }
        } else if (data.message_type === 'music') {
            // Create custom media player div (matching server-rendered markup)
            const playerDiv = document.createElement('div');
            playerDiv.className = 'custom-media-player';
            playerDiv.setAttribute('data-type', 'audio');
            
            // Create audio element
            const audio = document.createElement('audio');
            audio.className = 'cmp-media';
            audio.setAttribute('preload', 'metadata');
            const source = document.createElement('source');
            source.src = data.file_url;
            source.type = 'audio/mpeg';
            audio.appendChild(source);
            playerDiv.appendChild(audio);
            
            // Create controls container
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'cmp-controls';
            
            // Play button
            const playBtn = document.createElement('button');
            playBtn.className = 'cmp-play';
            playBtn.setAttribute('aria-label', 'Play');
            playBtn.textContent = '‚ñ∂';
            controlsDiv.appendChild(playBtn);
            
            // Progress bar
            const progressDiv = document.createElement('div');
            progressDiv.className = 'cmp-progress';
            progressDiv.setAttribute('role', 'progressbar');
            progressDiv.setAttribute('aria-valuemin', '0');
            progressDiv.setAttribute('aria-valuemax', '100');
            progressDiv.setAttribute('aria-valuenow', '0');
            const filledDiv = document.createElement('div');
            filledDiv.className = 'cmp-progress-filled';
            progressDiv.appendChild(filledDiv);
            controlsDiv.appendChild(progressDiv);
            
            // Time display
            const timeDiv = document.createElement('div');
            timeDiv.className = 'cmp-time';
            timeDiv.textContent = '0:00 / 0:00';
            controlsDiv.appendChild(timeDiv);
            
            // Volume control
            const volumeWrap = document.createElement('div');
            volumeWrap.className = 'cmp-volume-wrap';
            const volumeInput = document.createElement('input');
            volumeInput.type = 'range';
            volumeInput.className = 'cmp-volume';
            volumeInput.min = '0';
            volumeInput.max = '1';
            volumeInput.step = '0.01';
            volumeInput.value = '1';
            volumeInput.setAttribute('aria-label', 'Volume');
            volumeWrap.appendChild(volumeInput);
            controlsDiv.appendChild(volumeWrap);
            
            playerDiv.appendChild(controlsDiv);
            msgTextDiv.appendChild(playerDiv);
            
            // Add track info (title from filename or data)
            const trackTitle = data.file_name || data.file_url.split('/').pop();
            if (trackTitle) {
                const titleDiv = document.createElement('div');
                titleDiv.style.marginTop = '6px';
                titleDiv.style.fontSize = '0.9rem';
                titleDiv.style.fontWeight = '500';
                titleDiv.style.color = 'var(--text-main)';
                // Remove file extension and decode URL-encoded names
                let displayName = trackTitle.replace(/\.[^.]+$/, '');
                try {
                    displayName = decodeURIComponent(displayName);
                } catch (e) {}
                // Replace underscores and dashes with spaces for readability
                displayName = displayName.replace(/[_-]/g, ' ');
                titleDiv.textContent = displayName;
                msgTextDiv.appendChild(titleDiv);
            }
            
            // Add download link
            const downloadDiv = document.createElement('div');
            downloadDiv.style.marginTop = '8px';
            downloadDiv.style.display = 'flex';
            downloadDiv.style.gap = '8px';
            downloadDiv.style.fontSize = '0.9rem';
            const downloadLink = document.createElement('a');
            downloadLink.href = data.file_url;
            downloadLink.download = '';
            downloadLink.style.color = '#007bff';
            downloadLink.style.fontWeight = '600';
            downloadLink.textContent = 'Download';
            downloadDiv.appendChild(downloadLink);
            msgTextDiv.appendChild(downloadDiv);
            
            // Add caption if present
            if (data.msg) {
                const textDiv = document.createElement('div');
                textDiv.className = 'msg-text';
                textDiv.style.marginTop = '8px';
                textDiv.textContent = data.msg || '';
                msgTextDiv.appendChild(textDiv);
            }
        } else if (data.message_type === 'video') {
            // Create custom media player div for video (matching server-rendered markup)
            const playerDiv = document.createElement('div');
            playerDiv.className = 'custom-media-player video-player';
            playerDiv.setAttribute('data-type', 'video');
            
            // Create video element
            const video = document.createElement('video');
            video.className = 'cmp-media';
            video.setAttribute('preload', 'metadata');
            video.setAttribute('playsinline', '');
            const source = document.createElement('source');
            source.src = data.file_url;
            source.type = 'video/mp4';
            video.appendChild(source);
            playerDiv.appendChild(video);
            
            // Create controls container
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'cmp-controls';
            
            // Play button
            const playBtn = document.createElement('button');
            playBtn.className = 'cmp-play';
            playBtn.setAttribute('aria-label', 'Play');
            playBtn.textContent = '‚ñ∂';
            controlsDiv.appendChild(playBtn);
            
            // Progress bar
            const progressDiv = document.createElement('div');
            progressDiv.className = 'cmp-progress';
            progressDiv.setAttribute('role', 'progressbar');
            progressDiv.setAttribute('aria-valuemin', '0');
            progressDiv.setAttribute('aria-valuemax', '100');
            progressDiv.setAttribute('aria-valuenow', '0');
            const filledDiv = document.createElement('div');
            filledDiv.className = 'cmp-progress-filled';
            progressDiv.appendChild(filledDiv);
            controlsDiv.appendChild(progressDiv);
            
            // Time display
            const timeDiv = document.createElement('div');
            timeDiv.className = 'cmp-time';
            timeDiv.textContent = '0:00 / 0:00';
            controlsDiv.appendChild(timeDiv);
            
            // Volume control
            const volumeWrap = document.createElement('div');
            volumeWrap.className = 'cmp-volume-wrap';
            const volumeInput = document.createElement('input');
            volumeInput.type = 'range';
            volumeInput.className = 'cmp-volume';
            volumeInput.min = '0';
            volumeInput.max = '1';
            volumeInput.step = '0.01';
            volumeInput.value = '1';
            volumeInput.setAttribute('aria-label', 'Volume');
            volumeWrap.appendChild(volumeInput);
            controlsDiv.appendChild(volumeWrap);
            
            // Fullscreen button
            const fullscreenBtn = document.createElement('button');
            fullscreenBtn.className = 'cmp-fullscreen';
            fullscreenBtn.setAttribute('aria-label', 'Fullscreen');
            fullscreenBtn.textContent = '‚§¢';
            controlsDiv.appendChild(fullscreenBtn);
            
            playerDiv.appendChild(controlsDiv);
            msgTextDiv.appendChild(playerDiv);
            
            // Add caption if present
            if (data.msg) {
                const textDiv = document.createElement('div');
                textDiv.className = 'msg-text';
                textDiv.style.marginTop = '8px';
                textDiv.textContent = data.msg || '';
                msgTextDiv.appendChild(textDiv);
            }
        } else if (data.message_type === 'file') {
            const fileDiv = document.createElement('div');
            fileDiv.className = 'message-file';
            fileDiv.style.display = 'flex';
            fileDiv.style.alignItems = 'center';
            const iconDiv = document.createElement('div');
            iconDiv.className = 'file-icon';
            iconDiv.textContent = 'üìé';
            fileDiv.appendChild(iconDiv);
            const contentDiv = document.createElement('div');
            contentDiv.style.flex = '1';
            const fileNameDiv = document.createElement('div');
            fileNameDiv.style.fontWeight = 'bold';
            fileNameDiv.textContent = data.file_name || '–§–∞–π–ª';
            contentDiv.appendChild(fileNameDiv);
            const linksDiv = document.createElement('div');
            linksDiv.style.fontSize = '0.8em';
            linksDiv.style.color = '#aaa';
            const previewLink = document.createElement('a');
            previewLink.href = data.file_url;
            previewLink.onclick = (e) => { e.preventDefault(); previewFile(data.file_url); return false; };
            previewLink.style.color = '#007bff';
            previewLink.style.marginRight = '10px';
            previewLink.textContent = '–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä';
            linksDiv.appendChild(previewLink);
            const downloadLink = document.createElement('a');
            downloadLink.href = data.file_url;
            downloadLink.download = '';
            downloadLink.style.color = '#007bff';
            downloadLink.textContent = '–°–∫–∞—á–∞—Ç—å';
            linksDiv.appendChild(downloadLink);
            contentDiv.appendChild(linksDiv);
            fileDiv.appendChild(contentDiv);
            msgTextDiv.appendChild(fileDiv);
            if (data.msg) {
                const textDiv = document.createElement('div');
                textDiv.className = 'msg-text';
                textDiv.textContent = data.msg || '';
                msgTextDiv.appendChild(textDiv);
            }
        } else {
            // –û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç - –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∏ —Ä–µ–Ω–¥–µ—Ä–∏–º —Å <br>
            let text = (data.msg || '').replace(/^\n+/, '').replace(/\n+$/, '');
            const lines = text.split('\n');
            const cleanedLines = [];
            let foundFirstNonEmpty = false;
            for (let line of lines) {
                if (line.trim()) {
                    foundFirstNonEmpty = true;
                }
                if (foundFirstNonEmpty || line.trim()) {
                    cleanedLines.push(line.trimStart());
                }
            }
            while (cleanedLines.length > 0 && !cleanedLines[cleanedLines.length - 1].trim()) {
                cleanedLines.pop();
            }
            // Set plain text; `pre-wrap` CSS will preserve line breaks
            msgTextDiv.textContent = cleanedLines.join('\n');
        }
        // Ensure messagesDiv exists before appending
        if (!window.messagesDiv) {
            window.messagesDiv = document.getElementById('messages') || document.querySelector('.messages-container');
        }
        if (!window.messagesDiv) {
            console.error('Cannot append message: messagesDiv not found');
            return;
        }
        window.messagesDiv.appendChild(div);
        console.log('[DEBUG] Message appended to DOM, calling upgradeNativeMediaElements');
        try { upgradeNativeMediaElements(div); } catch (e) { console.error('upgrade on addMessage failed', e); }
        // After upgrading, initialize the new media players
        try { initializeMediaPlayers(); } catch (e) { console.error('initializeMediaPlayers after addMessage failed', e); }
        // Render reactions if provided by server in payload
        const mid = data.id || data.message_id;
        if (data.reactions) {
            try { updateMessageReactions(mid, data.reactions); } catch (e) { console.error('updateMessageReactions failed', e); }
        }
        // Apply any pending reactions that arrived before this message was added
        if (pendingReactions[mid]) {
            try { updateMessageReactions(mid, pendingReactions[mid]); } catch (e) { console.error('apply pending reactions failed', e); }
            delete pendingReactions[mid];
        }
        // Render local timestamps and day separators after adding a message
        renderTimestampsAndSeparators();
        // Only auto-scroll if user was already near the bottom
        if (wasNearBottom) {
            window.messagesDiv.scrollTop = window.messagesDiv.scrollHeight;
        }
        // Update FAB visibility
        if (window.setupJumpFAB) {
            try { window.setupJumpFAB(); } catch (e) { console.error('setupJumpFAB call failed', e); }
        }
    }
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ç–µ–∫—Å—Ç –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    function normalizeExistingMessages() {
        const allMessages = window.messagesDiv.querySelectorAll('.msg-text');
        allMessages.forEach(msgTextEl => {
            if (msgTextEl.textContent && !msgTextEl.querySelector('img, audio, .message-file')) {
                // –¢–æ–ª—å–∫–æ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
                let text = msgTextEl.textContent;
                // –£–±–∏—Ä–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∏ –∫–æ–Ω–µ—á–Ω—ã–µ –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫
                text = text.replace(/^\n+/, '').replace(/\n+$/, '');
                // –£–±–∏—Ä–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏–∑ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏
                const lines = text.split('\n');
                const cleanedLines = [];
                let foundFirstNonEmpty = false;
                for (let line of lines) {
                    if (line.trim()) {
                        foundFirstNonEmpty = true;
                    }
                    if (foundFirstNonEmpty || line.trim()) {
                        cleanedLines.push(line.trimStart());
                    }
                }
                // –£–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤ –∫–æ–Ω—Ü–µ
                while (cleanedLines.length > 0 && !cleanedLines[cleanedLines.length - 1].trim()) {
                    cleanedLines.pop();
                }
                const finalText = String(cleanedLines.join('\n'));
                if (msgTextEl.textContent !== finalText) {
                    msgTextEl.textContent = finalText;
                }
            }
        });
    }

    // Render timestamps in user's local timezone and insert day separators
    function renderTimestampsAndSeparators() {
        const container = document.getElementById('messages');
        if (!container) return;

        const messages = Array.from(container.querySelectorAll('.message'));
        let lastDate = null;

        // Remove existing separators
        Array.from(container.querySelectorAll('.day-separator')).forEach(el => el.remove());

        messages.forEach(msgEl => {
            const timeSpan = msgEl.querySelector('.msg-time');
            const ts = timeSpan ? timeSpan.getAttribute('data-timestamp') : null;
            let localDateStr = null;
            if (ts) {
                // Ensure UTC marker
                const iso = ts.endsWith('Z') ? ts : ts + 'Z';
                const d = new Date(iso);
                if (!isNaN(d.getTime())) {
                    // format time HH:MM
                    const hh = String(d.getHours()).padStart(2, '0');
                    const mm = String(d.getMinutes()).padStart(2, '0');
                    timeSpan.textContent = `${hh}:${mm}`;
                    // compute local date key
                    localDateStr = d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0');
                }
            }

            // handle edited label timestamp if present
            const editedSpan = msgEl.querySelector('.msg-edited');
            if (editedSpan) {
                const ets = editedSpan.getAttribute('data-edited-at');
                if (ets) {
                    const eiso = ets.endsWith('Z') ? ets : ets + 'Z';
                    const ed = new Date(eiso);
                    if (!isNaN(ed.getTime())) {
                        const eh = String(ed.getHours()).padStart(2, '0');
                        const em = String(ed.getMinutes()).padStart(2, '0');
                        editedSpan.textContent = `(–∏–∑–º–µ–Ω–µ–Ω–æ ${eh}:${em})`;
                    }
                }
            }

            // Insert day separator if date changed
            if (localDateStr && localDateStr !== lastDate) {
                lastDate = localDateStr;
                const sep = document.createElement('div');
                sep.className = 'day-separator';
                sep.style.textAlign = 'center';
                sep.style.margin = '10px 0';
                sep.style.color = '#b9bbbe';
                sep.style.fontSize = '0.85em';
                sep.style.position = 'relative';
                sep.style.display = 'flex';
                sep.style.alignItems = 'center';
                sep.style.justifyContent = 'center';
                sep.style.gap = '10px';
                sep.innerHTML = `<div style="background:#2f3136;padding:6px 12px;border-radius:12px;">${formatDateLabel(new Date(localDateStr))}</div>`;
                container.insertBefore(sep, msgEl);
            }
        });
    }

    function formatDateLabel(d) {
        const today = new Date();
        const yest = new Date();
        yest.setDate(today.getDate() - 1);

        function sameDay(a,b){return a.getFullYear()===b.getFullYear()&&a.getMonth()===b.getMonth()&&a.getDate()===b.getDate();}

        if (sameDay(d,today)) return '–°–µ–≥–æ–¥–Ω—è';
        if (sameDay(d,yest)) return '–í—á–µ—Ä–∞';
        // otherwise localized date
        try {
            return d.toLocaleDateString(undefined, { day: 'numeric', month: 'short', year: 'numeric' });
        } catch (e) {
            return `${d.getDate()}.${d.getMonth()+1}.${d.getFullYear()}`;
        }
    }

    function showFullscreen(url) {
        document.getElementById('fullscreenImage').src = url;
        document.getElementById('fullscreenOverlay').style.display = 'flex';
    }

    function previewFile(url) {
        window.open(url, '_blank');
    }

    function showProfile(userId, event) {
        if (event) {
            event.stopPropagation();
        }
        fetch(`/profile/${userId}?room_id=${window.roomId || ''}`)
            .then(r => {
                return r.text().then(html => ({ ok: r.ok, status: r.status, text: html }));
            })
            .then(resp => {
                const modal = document.getElementById('profilePreview');
                if (!resp.ok) {
                    // show error inside modal
                    modal.innerHTML = `<div style="padding:20px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è (HTTP ${resp.status})</div>`;
                    modal.style.display = 'block';
                    return;
                }
                // Insert HTML
                modal.innerHTML = resp.text;
                modal.style.display = 'block';
                // Execute any scripts included in the fetched HTML so event handlers bind
                try {
                    const scripts = Array.from(modal.querySelectorAll('script'));
                    scripts.forEach(s => {
                        const ns = document.createElement('script');
                        if (s.src) {
                            ns.src = s.src;
                            ns.async = false;
                        } else {
                            ns.textContent = s.textContent;
                        }
                        document.head.appendChild(ns);
                        s.remove();
                    });
                } catch (e) { console.error('Executing profile scripts failed', e); }
            // Position modal near click but ensure it stays inside viewport
            modal.style.transform = 'none';
            if (event) {
                // initial position
                let left = event.clientX + 10;
                let top = event.clientY + 10;
                // clamp
                const pad = 10;
                const maxLeft = Math.max(pad, window.innerWidth - modal.offsetWidth - pad);
                const maxTop = Math.max(pad, window.innerHeight - modal.offsetHeight - pad);
                if (left > maxLeft) left = maxLeft;
                if (top > maxTop) top = maxTop;
                modal.style.left = left + 'px';
                modal.style.top = top + 'px';
            } else {
                modal.style.left = '50%';
                modal.style.top = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
            }

            // If profile contains audio elements, ensure they stop others when played
            try {
                modal.querySelectorAll('audio').forEach(a => {
                    a.onplay = () => pauseAllOtherAudio(a);
                });
            } catch (e) {}
        });
    }

    document.addEventListener('click', function(e) {
        if (!e.target.closest('#profilePreview') && !e.target.closest('.avatar-clickable') && !e.target.closest('.msg-meta span')) {
            document.getElementById('profilePreview').style.display = 'none';
        }
    });

    function editChannel(id, name, description, emoji, iconUrl) {
        document.getElementById('edit_channel_id').value = id;
        document.getElementById('edit_channel_name').value = name;
        document.getElementById('edit_channel_description').value = description || '';
        document.getElementById('edit_channel_emoji').value = emoji || '';
        document.getElementById('channelEditModal').style.display = 'block';
    }

    function saveChannelEdit(e) {
        e.preventDefault();
        const formData = new FormData();
        formData.append('name', document.getElementById('edit_channel_name').value);
        formData.append('description', document.getElementById('edit_channel_description').value);
        formData.append('icon_emoji', document.getElementById('edit_channel_emoji').value);
        
        const iconFile = document.getElementById('edit_channel_icon').files[0];
        if (iconFile) {
            formData.append('icon_file', iconFile);
        }
        
        const channelId = document.getElementById('edit_channel_id').value;
        
        fetch(`/room/${window.roomId}/channel/${channelId}/edit`, {
            method: 'POST',
            body: formData
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                location.reload();
            } else {
                showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
            }
        });
    }

    function deleteChannel(channelId) {
        showConfirm('–£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–∞–ª', '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –∫–∞–Ω–∞–ª? –í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã.', () => {
            fetch(`/room/${window.roomId}/channel/${channelId}/delete`, { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    if (channelId == {{ active_channel_id }}) {
                        window.location.href = "{{ url_for('main.view_room', room_id=room.id) }}";
                    } else {
                        location.reload();
                    }
                } else {
                    showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
                }
            });
        });
    }
    
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    
    // ========== –°–¢–ò–õ–ò–ó–û–í–ê–ù–ù–´–ï –ú–û–î–ê–õ–¨–ù–´–ï –û–ö–ù–ê ==========
    
    function showConfirm(title, message, onConfirm, btnText = '–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', btnClass = 'danger') {
        document.getElementById('confirmTitle').textContent = title;
        document.getElementById('confirmMessage').textContent = message;
        const btn = document.getElementById('confirmBtn');
        btn.textContent = btnText;
        btn.className = `modal-btn modal-btn-${btnClass}`;
        confirmCallback = onConfirm;
        document.getElementById('confirmModal').style.display = 'flex';
    }
    
    function closeConfirmModal(result) {
        document.getElementById('confirmModal').style.display = 'none';
        if (result && confirmCallback) {
            confirmCallback();
        }
        confirmCallback = null;
    }
    
    function showAlert(message) {
        document.getElementById('alertMessage').textContent = message;
        document.getElementById('alertModal').style.display = 'flex';
    }
    
    function closeAlertModal() {
        document.getElementById('alertModal').style.display = 'none';
    }
    
    // ========== –ö–û–ù–¢–ï–ö–°–¢–ù–û–ï –ú–ï–ù–Æ ==========
    
    function showContextMenu(x, y) {
        const menu = document.getElementById('messageContextMenu');
        menu.style.display = 'block';
        menu.style.left = Math.min(x, window.innerWidth - 220) + 'px';
        menu.style.top = Math.min(y, window.innerHeight - 200) + 'px';
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –ø—É–Ω–∫—Ç—ã –º–µ–Ω—é –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∞–≤
        const msgEl = contextMenuMessageElement;
        let canEdit = false;
        try {
            if (msgEl) {
                const contentEl = msgEl.querySelector('.message-content');
                console.log('[showContextMenu] msgEl:', msgEl);
                console.log('[showContextMenu] contentEl:', contentEl);
                console.log('[showContextMenu] contentEl.dataset:', contentEl ? contentEl.dataset : 'null');
                console.log('[showContextMenu] contentEl.dataset.userId:', contentEl ? contentEl.dataset.userId : 'null');
                
                if (contentEl && contentEl.dataset && contentEl.dataset.userId) {
                    const msgUserId = Number(contentEl.dataset.userId);
                    const currentId = Number(window.currentUserId);
                    canEdit = msgUserId === currentId;
                    console.log('[showContextMenu] Check: msgUserId=' + msgUserId + ', currentId=' + currentId + ', match=' + canEdit);
                } else {
                    console.warn('[showContextMenu] No userId in dataset. Available:', contentEl ? Object.keys(contentEl.dataset) : 'no contentEl');
                }
            }
        } catch (e) { console.error('showContextMenu compute canEdit failed', e); }
        const canDelete = msgEl && (canEdit || window.userRole == 'owner' || window.userRole == 'admin');
        
        console.log('[showContextMenu] Final: canEdit=' + canEdit + ', canDelete=' + canDelete + ', userRole=' + window.userRole);
        
        menu.querySelectorAll('.context-menu-item')[2].style.display = canEdit ? 'flex' : 'none'; // –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
        menu.querySelectorAll('.context-menu-item')[6].style.display = canDelete ? 'flex' : 'none'; // –£–¥–∞–ª–∏—Ç—å
    }
    
    function hideContextMenu() {
        document.getElementById('messageContextMenu').style.display = 'none';
    }
    
    function copyMessage() {
        if (!contextMenuMessageElement) return;
        const textEl = contextMenuMessageElement.querySelector('.msg-text');
        if (textEl) {
            const text = textEl.textContent || textEl.innerText;
            navigator.clipboard.writeText(text).then(() => {
                showAlert('–°–æ–æ–±—â–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
            });
        }
        hideContextMenu();
    }

    function replyToMessageFromMenu() {
        if (!contextMenuMessageId || !contextMenuMessageElement) return;
        const textEl = contextMenuMessageElement.querySelector('.msg-text');
        let snippet = '';
        if (textEl) {
            snippet = (textEl.textContent || textEl.innerText || '').trim();
            snippet = snippet.split('\n')[0].slice(0, 200);
        }
        const metaAuthor = contextMenuMessageElement.querySelector('.msg-meta span');
        const username = metaAuthor ? (metaAuthor.textContent || 'Unknown') : 'Unknown';
        window.replyTo = { id: contextMenuMessageId, username: username, snippet: snippet };
        const preview = document.getElementById('replyPreview');
        const previewContent = document.getElementById('replyPreviewContent');
        if (preview && previewContent) {
            previewContent.textContent = username + ': ' + snippet;
            preview.style.display = 'block';
        }
        hideContextMenu();
    }

    function clearReply() {
        window.replyTo = null;
        const preview = document.getElementById('replyPreview');
        const previewContent = document.getElementById('replyPreviewContent');
        if (preview) preview.style.display = 'none';
        if (previewContent) previewContent.textContent = '';
    }

    // Channel context menu functions
    function showChannelContextMenu(e, channelId) {
        console.log('showChannelContextMenu called with channelId:', channelId);
        e.preventDefault();
        e.stopPropagation();
        contextMenuChannelId = channelId;
        
        // Get channel data from the channel-item element
        const channelElement = e.target.closest('.channel-item');
        if (channelElement) {
            contextMenuChannelData = {
                id: channelElement.dataset.channelId,
                name: channelElement.dataset.channelName,
                description: channelElement.dataset.channelDescription,
                emoji: channelElement.dataset.channelEmoji,
                iconUrl: channelElement.dataset.channelIconUrl
            };
            console.log('Channel data:', contextMenuChannelData);
        }
        
        const menu = document.getElementById('channelContextMenu');
        if (!menu) {
            console.log('Menu element not found!');
            return false;
        }
        menu.style.display = 'block';
        menu.style.left = Math.min(e.clientX, window.innerWidth - 220) + 'px';
        menu.style.top = Math.min(e.clientY, window.innerHeight - 140) + 'px';
        console.log('Menu displayed at', menu.style.left, menu.style.top);
        setupChannelMenuClose();
        return false;
    }

    function hideChannelContextMenu() {
        const menu = document.getElementById('channelContextMenu');
        if (menu) {
            menu.style.display = 'none';
            removeChannelMenuOverlay();
        }
        contextMenuChannelId = null;
    }

    function goToChannel(channelId, url) {
        console.log('goToChannel called with channelId:', channelId, 'url:', url);
        try { if (window.socket && channelId) window.socket.emit('join', {channel_id: Number(channelId)}); } catch (e) { console.error('Socket join error:', e); }
        // navigate to channel URL
        location.href = url;
    }

    // Close channel context menu when clicking outside
    function setupChannelMenuClose() {
        const menu = document.getElementById('channelContextMenu');
        if (!menu) return;
        
        // Remove existing overlay if any
        const existingOverlay = document.getElementById('channelMenuOverlay');
        if (existingOverlay) existingOverlay.remove();
        
        // Create invisible overlay to catch clicks
        const overlay = document.createElement('div');
        overlay.id = 'channelMenuOverlay';
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.zIndex = '999'; // Just below menu which is 1000
        overlay.style.cursor = 'default';
        
        overlay.addEventListener('click', function(e) {
            console.log('Overlay clicked, closing menu');
            hideChannelContextMenu();
        });
        
        document.body.appendChild(overlay);
    }
    
    function removeChannelMenuOverlay() {
        const overlay = document.getElementById('channelMenuOverlay');
        if (overlay) overlay.remove();
    }

    function editChannelFromContext() {
        if (!contextMenuChannelId) return;
        hideChannelContextMenu();
        editChannel(
            contextMenuChannelData.id,
            contextMenuChannelData.name,
            contextMenuChannelData.description,
            contextMenuChannelData.emoji,
            contextMenuChannelData.iconUrl
        );
    }

    function deleteChannelFromContext() {
        if (!contextMenuChannelId) return;
        hideChannelContextMenu();
        deleteChannel(contextMenuChannelId);
    }
    
    function editMessage() {
        if (!contextMenuMessageId || !contextMenuMessageElement) return;
        const textEl = contextMenuMessageElement.querySelector('.msg-text');
        if (!textEl) return;
        
        const currentText = textEl.textContent;
        
        // –°–æ–∑–¥–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        modal.innerHTML = `
            <div class="modal">
                <div class="modal-header">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</div>
                <div class="modal-body">
                    <textarea id="editMessageText" class="input-box" style="width: 100%; min-height: 100px; font-family: inherit;">${currentText}</textarea>
                </div>
                <div class="modal-footer">
                    <button class="modal-btn modal-btn-secondary" onclick="this.closest('.modal-overlay').remove()">–û—Ç–º–µ–Ω–∞</button>
                    <button class="modal-btn modal-btn-primary" onclick="saveEditedMessage(${contextMenuMessageId})">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        document.getElementById('editMessageText').focus();
        document.getElementById('editMessageText').select();
        
        hideContextMenu();
    }
    
    function saveEditedMessage(messageId) {
        const textarea = document.getElementById('editMessageText');
        const newText = textarea.value.trim();
        const modal = textarea.closest('.modal-overlay');
        
        if (!newText) {
            showAlert('–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º');
            return;
        }
        
        fetch(`/message/${messageId}/edit`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({content: newText})
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                modal.remove();

                // Immediately update the message locally for the editor
                const msgEl = document.querySelector(`[data-msg-id="${messageId}"]`);
                if (msgEl) {
                    const textEl = msgEl.querySelector('.msg-text');
                    if (textEl) {
                        textEl.innerHTML = '';
                        // preserve newlines by setting textContent; CSS will render breaks
                        textEl.textContent = data.content || newText;
                        normalizeMessageText(msgEl);
                    }

                    const metaEl = msgEl.querySelector('.msg-meta');
                    if (metaEl) {
                        // Remove existing edited marker
                        const oldEdited = metaEl.querySelector('.msg-edited');
                        if (oldEdited) oldEdited.remove();
                        if (data.edited_at_iso) {
                            const editedSpan = document.createElement('span');
                            editedSpan.className = 'msg-edited';
                            editedSpan.setAttribute('data-edited-at', data.edited_at_iso);
                            editedSpan.style.color = '#72767d';
                            editedSpan.style.fontSize = '0.85em';
                            editedSpan.style.marginLeft = '5px';
                            editedSpan.textContent = '(–∏–∑–º–µ–Ω–µ–Ω–æ)';
                            metaEl.appendChild(editedSpan);
                        }
                    }

                    // Update reactions if returned
                    if (data.reactions) {
                        updateMessageReactions(data.message_id, data.reactions);
                    }

                    // Re-render timestamps and separators to reflect edited time
                    renderTimestampsAndSeparators();
                }
                
                // Other clients will receive socket 'message_edited' and update accordingly
            } else {
                showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
            }
        });
    }
    
    function forwardMessage() {
        if (!contextMenuMessageId) return;
        hideContextMenu();
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
        fetch('/channels/accessible')
        .then(r => r.json())
        .then(data => {
            if (data.channels.length === 0) {
                showAlert('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏');
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–∞–Ω–∞–ª–∞
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            
            let optionsHtml = '';
            // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∫–æ–º–Ω–∞—Ç–∞–º
            const roomsMap = {};
            data.channels.forEach(ch => {
                if (!roomsMap[ch.room_id]) {
                    roomsMap[ch.room_id] = {
                        room_name: ch.room_name,
                        room_type: ch.room_type,
                        channels: []
                    };
                }
                roomsMap[ch.room_id].channels.push(ch);
            });
            
            for (const [roomId, roomData] of Object.entries(roomsMap)) {
                optionsHtml += `<optgroup label="${roomData.room_name}">`;
                roomData.channels.forEach(ch => {
                    const prefix = roomData.room_type === 'dm' ? 'üí¨' : '#';
                    optionsHtml += `<option value="${ch.id}">${prefix} ${ch.name}</option>`;
                });
                optionsHtml += `</optgroup>`;
            }
            
            modal.innerHTML = `
                <div class="modal">
                    <div class="modal-header">–ü–µ—Ä–µ—Å–ª–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</div>
                    <div class="modal-body">
                        <label style="display: block; margin-bottom: 5px;">–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª:</label>
                        <select id="forwardChannelSelect" class="input-box" style="width: 100%; margin-bottom: 15px;">
                            ${optionsHtml}
                        </select>
                    </div>
                    <div class="modal-footer">
                        <button class="modal-btn modal-btn-secondary" onclick="this.closest('.modal-overlay').remove()">–û—Ç–º–µ–Ω–∞</button>
                        <button class="modal-btn modal-btn-primary" onclick="confirmForwardMessage(${contextMenuMessageId})">–ü–µ—Ä–µ—Å–ª–∞—Ç—å</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        });
    }
    
    function confirmForwardMessage(messageId) {
        const select = document.getElementById('forwardChannelSelect');
        const channelId = select.value;
        const modal = select.closest('.modal-overlay');
        
        fetch(`/message/${messageId}/forward`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({channel_id: parseInt(channelId)})
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                modal.remove();
                showAlert('–°–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–ª–∞–Ω–æ');
            } else {
                showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
            }
        });
    }
    
    function deleteMessageFromMenu() {
        if (!contextMenuMessageId) return;
        hideContextMenu();
        showConfirm('–£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ', '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ?', () => {
            fetch(`/message/${contextMenuMessageId}/delete`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const msgElement = document.querySelector(`[data-msg-id="${contextMenuMessageId}"]`);
                    if (msgElement) {
                        msgElement.remove();
                    }
                } else {
                    showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
                }
            });
        });
    }
    
    
    // ========== –†–ï–ê–ö–¶–ò–ò ==========
    
    function showReactionPicker() {
        if (!contextMenuMessageId) return;
        hideContextMenu();
        const picker = document.getElementById('emojiPicker');
        const grid = document.getElementById('emojiGrid');
        grid.innerHTML = '';
        
        commonEmojis.forEach(emoji => {
            const item = document.createElement('div');
            item.className = 'emoji-item';
            item.textContent = emoji;
            item.onclick = () => {
                toggleReaction(contextMenuMessageId, emoji);
                picker.style.display = 'none';
            };
            grid.appendChild(item);
        });
        
        const menu = document.getElementById('messageContextMenu');
        let left = parseInt(menu.style.left);
        let top = parseInt(menu.style.top) + 150;
        
        // Ensure picker stays within viewport on mobile
        const pickerWidth = 320;
        const pickerHeight = 320;
        
        if (left + pickerWidth > window.innerWidth) {
            left = window.innerWidth - pickerWidth - 10;
        }
        if (top + pickerHeight > window.innerHeight) {
            top = window.innerHeight - pickerHeight - 10;
        }
        
        picker.style.left = left + 'px';
        picker.style.top = top + 'px';
        picker.style.display = 'block';
    }
    
    function toggleReaction(messageId, emoji) {
        fetch(`/message/${messageId}/reaction`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({emoji: emoji, reaction_type: 'emoji'})
        })
        .then(r => r.json())
        .then(data => {
            if (data.success) {
                updateMessageReactions(messageId, data.reactions);
            }
        });
    }
    
    function updateMessageReactions(messageId, reactions) {
        const msgEl = document.querySelector(`[data-msg-id="${messageId}"]`);
        if (!msgEl) return false;

        let reactionsEl = msgEl.querySelector('.message-reactions');
        if (!reactionsEl) {
            reactionsEl = document.createElement('div');
            reactionsEl.className = 'message-reactions';
            // prefer .msg-bubble, fall back to .message-content, then legacy .msg-content
            const container = msgEl.querySelector('.msg-bubble') || msgEl.querySelector('.message-content') || msgEl.querySelector('.msg-content');
            if (!container) return false;
            container.appendChild(reactionsEl);
        }
        
        reactionsEl.innerHTML = '';
        if (!reactions || Object.keys(reactions).length === 0) {
            reactionsEl.remove();
            return;
        }
        
        for (const [emoji, users] of Object.entries(reactions)) {
            const reaction = document.createElement('div');
            reaction.className = 'reaction';
            if (users.includes(currentUsername)) {
                reaction.classList.add('active');
            }
            reaction.onclick = () => toggleReaction(messageId, emoji);
            reaction.innerHTML = `
                <span class="reaction-emoji">${emoji}</span>
                <span class="reaction-count">${users.length}</span>
            `;
            reactionsEl.appendChild(reaction);
        }
        return true;
    }
    
    // Bind reactions listener - will be called after socket is ready
    function setupReactionsListener() {
        if (!window.socket) {
            setTimeout(setupReactionsListener, 50);
            return;
        }
        if (window.socket._reactionsListenerAttached) {
            return; // Already attached
        }
        window.socket._reactionsListenerAttached = true;
        window.socket.on('reactions_updated', function(data) {
            console.debug('[socket.reactions_updated] received:', data);
            // If the message element isn't present yet, queue the reactions
            const ok = updateMessageReactions(data.message_id, data.reactions);
            if (!ok) {
                pendingReactions[data.message_id] = data.reactions;
            }
        });
        console.debug('[setupReactionsListener] Reactions listener attached');
    }
    
    // Call this after socket is initialized
    if (typeof io !== 'undefined') {
        setupReactionsListener();
    }

    
    // Bind message edited listener - will be called after socket is ready
    function setupMessageEditedListener() {
        if (!window.socket) {
            setTimeout(setupMessageEditedListener, 50);
            return;
        }
        if (window.socket._messageEditedListenerAttached) {
            return; // Already attached
        }
        window.socket._messageEditedListenerAttached = true;
        window.socket.on('message_edited', function(data) {
            console.debug('[socket.message_edited] received:', data);
            const msgEl = document.querySelector(`[data-msg-id="${data.message_id}"]`);
            if (msgEl) {
                const textEl = msgEl.querySelector('.msg-text');
                if (textEl) {
                    textEl.innerHTML = '';
                    textEl.textContent = data.content;
                    normalizeMessageText(msgEl);
                }
                const metaEl = msgEl.querySelector('.msg-meta');
                if (metaEl && data.edited_at_iso) {
                    const oldEdited = metaEl.querySelector('.msg-edited');
                    if (oldEdited) oldEdited.remove();
                    const editedSpan = document.createElement('span');
                    editedSpan.className = 'msg-edited';
                    editedSpan.setAttribute('data-edited-at', data.edited_at_iso);
                    editedSpan.style.color = '#72767d';
                    editedSpan.style.fontSize = '0.85em';
                    editedSpan.style.marginLeft = '5px';
                    editedSpan.textContent = '(–∏–∑–º–µ–Ω–µ–Ω–æ)';
                    metaEl.appendChild(editedSpan);
                    renderTimestampsAndSeparators();
                }
                if (data.reactions) {
                    updateMessageReactions(data.message_id, data.reactions);
                }
                if (contextMenuMessageId === data.message_id) {
                    contextMenuMessageElement = msgEl;
                }
            }
        });
        console.debug('[setupMessageEditedListener] Message edited listener attached');
    }
    
    // ========== –°–¢–ò–ö–ï–†–´ ==========
    function loadStickerPacks() {
        fetch('/stickerpacks')
        .then(r => r.json())
        .then(data => {
            const container = document.getElementById('stickerPacksContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            data.packs.forEach(pack => {
                const packIcon = document.createElement('div');
                packIcon.className = 'server-icon';
                packIcon.title = pack.name;
                packIcon.textContent = pack.icon_emoji || 'üì¶';
                packIcon.onclick = () => showStickerPack(pack.id, pack.name);
                packIcon.style.cursor = 'pointer';
                packIcon.style.position = 'relative';
                
                // –ö–Ω–æ–ø–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
                const editBtn = document.createElement('button');
                editBtn.textContent = '‚úèÔ∏è';
                editBtn.style.position = 'absolute';
                editBtn.style.top = '-5px';
                editBtn.style.right = '-5px';
                editBtn.style.background = '#5865f2';
                editBtn.style.border = 'none';
                editBtn.style.borderRadius = '50%';
                editBtn.style.width = '20px';
                editBtn.style.height = '20px';
                editBtn.style.fontSize = '10px';
                editBtn.style.cursor = 'pointer';
                editBtn.style.display = 'none';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    editStickerPack(pack.id, pack.name, pack.icon_emoji);
                };
                packIcon.onmouseenter = () => editBtn.style.display = 'block';
                packIcon.onmouseleave = () => editBtn.style.display = 'none';
                packIcon.appendChild(editBtn);
                
                container.appendChild(packIcon);
            });
        });
    }
    
    function editStickerPack(packId, currentName, currentEmoji) {
        fetch('/stickerpacks')
        .then(r => r.json())
        .then(data => {
            const pack = data.packs.find(p => p.id === packId);
            if (!pack) return;
            
            const content = document.getElementById('editStickerPackContent');
            content.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <h4>${pack.name}</h4>
                    <p style="color: #72767d; font-size: 0.9em;">–°—Ç–∏–∫–µ—Ä–æ–≤: ${pack.stickers.length}</p>
                </div>
                <div style="margin-bottom: 15px;">
                    <button class="btn" onclick="addStickerToPack(${packId})" style="width: 100%; margin-bottom: 10px;">–î–æ–±–∞–≤–∏—Ç—å —Å—Ç–∏–∫–µ—Ä</button>
                    ${pack.stickers.length > 0 ? `<button class="btn btn-red" onclick="showDeleteStickerModal(${packId})" style="width: 100%; margin-bottom: 10px;">–£–¥–∞–ª–∏—Ç—å —Å—Ç–∏–∫–µ—Ä</button>` : ''}
                    <button class="btn btn-red" onclick="deleteStickerPackConfirm(${packId})" style="width: 100%;">–£–¥–∞–ª–∏—Ç—å —Å—Ç–∏–∫–µ—Ä–ø–∞–∫</button>
                </div>
                ${pack.stickers.length > 0 ? `
                <div style="max-height: 300px; overflow-y: auto;">
                    <h5>–°—Ç–∏–∫–µ—Ä—ã –≤ –ø–∞–∫–µ:</h5>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                        ${pack.stickers.map(s => `
                            <div style="text-align: center;">
                                <img src="${s.url}" style="width: 80px; height: 80px; object-fit: contain; border-radius: 4px;">
                                <div style="font-size: 0.8em; color: #72767d; margin-top: 5px;">${s.name}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
            `;
            document.getElementById('editStickerPackModal').style.display = 'flex';
        });
    }
    
    function addStickerToPack(packId) {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            showInputModal('–ù–∞–∑–≤–∞–Ω–∏–µ —Å—Ç–∏–∫–µ—Ä–∞', '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç–∏–∫–µ—Ä–∞:', (name) => {
                if (!name) return;
                
                const formData = new FormData();
                formData.append('sticker_file', file);
                formData.append('name', name);
                
                fetch(`/stickerpack/${packId}/add`, {
                    method: 'POST',
                    body: formData
                })
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        loadStickerPacks();
                        editStickerPack(packId);
                        showAlert('–°—Ç–∏–∫–µ—Ä –¥–æ–±–∞–≤–ª–µ–Ω!');
                    } else {
                        showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
                    }
                });
            });
        };
        input.click();
    }
    
    function showDeleteStickerModal(packId) {
        fetch('/stickerpacks')
        .then(r => r.json())
        .then(data => {
            const pack = data.packs.find(p => p.id === packId);
            if (!pack || pack.stickers.length === 0) {
                showAlert('–í —ç—Ç–æ–º —Å—Ç–∏–∫–µ—Ä–ø–∞–∫–µ –Ω–µ—Ç —Å—Ç–∏–∫–µ—Ä–æ–≤');
                return;
            }
            
            const content = document.getElementById('editStickerPackContent');
            content.innerHTML = `
                <h4>–£–¥–∞–ª–∏—Ç—å —Å—Ç–∏–∫–µ—Ä</h4>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 15px 0;">
                    ${pack.stickers.map((s, i) => `
                        <div style="text-align: center; cursor: pointer; padding: 10px; border-radius: 4px; border: 1px solid #4f545c;" onclick="deleteSticker(${s.id}, ${packId})">
                            <img src="${s.url}" style="width: 80px; height: 80px; object-fit: contain;">
                            <div style="font-size: 0.8em; color: #72767d; margin-top: 5px;">${s.name}</div>
                        </div>
                    `).join('')}
                </div>
                <button class="btn modal-btn-secondary" onclick="editStickerPack(${packId})" style="width: 100%;">–ù–∞–∑–∞–¥</button>
            `;
        });
    }
    
    function deleteSticker(stickerId, packId) {
        showConfirm('–£–¥–∞–ª–∏—Ç—å —Å—Ç–∏–∫–µ—Ä', '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —Å—Ç–∏–∫–µ—Ä?', () => {
            fetch(`/sticker/${stickerId}/delete`, { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    loadStickerPacks();
                    editStickerPack(packId);
                    showAlert('–°—Ç–∏–∫–µ—Ä —É–¥–∞–ª–µ–Ω!');
                }
            });
        });
    }
    
    function deleteStickerPackConfirm(packId) {
        showConfirm('–£–¥–∞–ª–∏—Ç—å —Å—Ç–∏–∫–µ—Ä–ø–∞–∫', '–í—ã —É–≤–µ—Ä–µ–Ω—ã? –í—Å–µ —Å—Ç–∏–∫–µ—Ä—ã –≤ —ç—Ç–æ–º –ø–∞–∫–µ –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã.', () => {
            fetch(`/stickerpack/${packId}/delete`, { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    loadStickerPacks();
                    closeModal('editStickerPackModal');
                    showAlert('–°—Ç–∏–∫–µ—Ä–ø–∞–∫ —É–¥–∞–ª–µ–Ω!');
                }
            });
        });
    }
    
    function closeModal(modalId) {
        document.getElementById(modalId).style.display = 'none';
    }
    
    function showInputModal(title, message, onConfirm) {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        modal.innerHTML = `
            <div class="modal">
                <div class="modal-header">${title}</div>
                <div class="modal-body">
                    <p>${message}</p>
                    <input type="text" id="inputModalValue" class="input-box" style="width: 100%;">
                </div>
                <div class="modal-footer">
                    <button class="modal-btn modal-btn-secondary" onclick="this.closest('.modal-overlay').remove()">–û—Ç–º–µ–Ω–∞</button>
                    <button class="modal-btn modal-btn-primary" onclick="
                        const value = document.getElementById('inputModalValue').value;
                        this.closest('.modal-overlay').remove();
                        if (value && typeof onConfirm === 'function') {
                            onConfirm(value);
                        }
                    ">–û–ö</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        document.getElementById('inputModalValue').focus();
        document.getElementById('inputModalValue').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                modal.querySelector('.modal-btn-primary').click();
            }
        });
    }
    
    function showStickerPack(packId, packName) {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∏–∫–µ—Ä—ã –∏–∑ —ç—Ç–æ–≥–æ –ø–∞–∫–∞ –≤ —Å—Ç–∏–∫–µ—Ä-–ø–∏–∫–µ—Ä–µ
        fetch('/stickerpacks')
        .then(r => r.json())
        .then(data => {
            const pack = data.packs.find(p => p.id === packId);
            if (!pack) return;
            
            const grid = document.getElementById('stickerGrid');
            grid.innerHTML = '';
            
            pack.stickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                const img = document.createElement('img');
                img.src = sticker.url;
                img.onclick = () => sendSticker(sticker.url);
                item.appendChild(img);
                grid.appendChild(item);
            });
            
            const picker = document.getElementById('stickerPicker');
            picker.style.display = 'block';
            picker.style.left = '20px';
            picker.style.top = (window.innerHeight - 450) + 'px';
        });
    }
    
    function sendSticker(stickerUrl) {
        socket.emit('send_message', {
            room_id: roomId,
            channel_id: channelId,
            msg: '',
            message_type: 'sticker',
            file_url: stickerUrl
        });
        document.getElementById('stickerPicker').style.display = 'none';
    }
    
    
    function toggleStickerPicker() {
        const picker = document.getElementById('stickerPicker');
        const isVisible = picker.style.display === 'block';
        document.getElementById('emojiPicker').style.display = 'none';
        if (isVisible) {
            picker.style.display = 'none';
        } else {
            picker.style.display = 'block';
            picker.style.left = '20px';
            picker.style.top = (window.innerHeight - 450) + 'px';
            loadStickerPacksForPicker();
        }
    }
    
    function loadStickerPacksForPicker() {
        fetch('/stickerpacks')
        .then(r => r.json())
        .then(data => {
            const packList = document.getElementById('stickerPackList');
            const grid = document.getElementById('stickerGrid');
            
            packList.innerHTML = '';
            grid.innerHTML = '';
            
            if (data.packs.length === 0) {
                grid.innerHTML = '<div style="text-align: center; color: #72767d; padding: 20px;">–ù–µ—Ç —Å—Ç–∏–∫–µ—Ä–ø–∞–∫–æ–≤. –°–æ–∑–¥–∞–π—Ç–µ —Å—Ç–∏–∫–µ—Ä–ø–∞–∫ –≤ sidebar!</div>';
                return;
            }
            
            // –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å—Ç–∏–∫–µ—Ä–ø–∞–∫–æ–≤ —Å–≤–µ—Ä—Ö—É
            data.packs.forEach((pack, index) => {
                const packBtn = document.createElement('button');
                packBtn.className = 'sticker-pack-btn';
                packBtn.textContent = pack.icon_emoji || 'üì¶';
                packBtn.title = pack.name;
                packBtn.style.cssText = 'background: #2f3136; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 1.2em;';
                packBtn.onclick = () => showStickerPackInPicker(pack.id);
                if (index === 0) {
                    packBtn.style.background = '#5865f2';
                    showStickerPackInPicker(pack.id);
                }
                packList.appendChild(packBtn);
            });
        });
    }
    
    function showStickerPackInPicker(packId) {
        fetch('/stickerpacks')
        .then(r => r.json())
        .then(data => {
            const pack = data.packs.find(p => p.id === packId);
            if (!pack) return;
            
            const grid = document.getElementById('stickerGrid');
            grid.innerHTML = '';
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Å—Ç–∏–∫–µ—Ä–ø–∞–∫
            document.querySelectorAll('.sticker-pack-btn').forEach((btn, i) => {
                const p = data.packs[i];
                if (p && p.id === packId) {
                    btn.style.background = '#5865f2';
                } else {
                    btn.style.background = '#2f3136';
                }
            });
            
            pack.stickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                const img = document.createElement('img');
                img.src = sticker.url;
                img.onclick = () => sendSticker(sticker.url);
                item.appendChild(img);
                grid.appendChild(item);
            });
        });
    }
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–∏–∫–µ—Ä—ã –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –∏—Ö
    document.addEventListener('click', function(e) {
        if (!e.target.closest('#stickerPicker') && !e.target.closest('button[onclick*="toggleStickerPicker"]')) {
            document.getElementById('stickerPicker').style.display = 'none';
        }
        if (!e.target.closest('#emojiPicker') && !e.target.closest('.context-menu-item')) {
            document.getElementById('emojiPicker').style.display = 'none';
        }
        // Hide context menus when clicking outside
        if (!e.target.closest('.context-menu')) {
            try { hideContextMenu(); } catch (e) {}
            try { hideChannelContextMenu(); } catch (e) {}
        }
    });
    
    function inviteToRoom(roomId) {
        console.log('inviteToRoom called with roomId:', roomId);
        fetch(`/room/${roomId}/invite`, { method: 'POST' })
        .then(r => r.json())
        .then(data => {
            console.log('Invite response:', data);
            if (data.success) {
                navigator.clipboard.writeText(data.invite_url).then(() => {
                    showAlert('–°—Å—ã–ª–∫–∞-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!');
                }).catch(() => {
                    // Fallback –µ—Å–ª–∏ clipboard API –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
                    const textarea = document.createElement('textarea');
                    textarea.value = data.invite_url;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        showAlert('–°—Å—ã–ª–∫–∞-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!');
                    } catch (err) {
                        showAlert('–°—Å—ã–ª–∫–∞: ' + data.invite_url);
                    }
                    document.body.removeChild(textarea);
                });
            } else {
                showAlert('–û—à–∏–±–∫–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
            }
        });
    }
    
    // Initialize custom media players
    function formatTime(sec) {
        if (!isFinite(sec)) return '0:00';
        const s = Math.floor(sec % 60).toString().padStart(2, '0');
        const m = Math.floor(sec / 60);
        return m + ':' + s;
    }

    function initializeMediaPlayers() {
        console.log('[DEBUG] initializeMediaPlayers called');
        const players = document.querySelectorAll('.custom-media-player');
        console.log('[DEBUG] Found', players.length, 'custom media player containers');
        // initialize any container that looks like a custom media player
        document.querySelectorAll('.custom-media-player').forEach((container, idx) => {
            if (!container) {
                console.log(`[DEBUG] Container ${idx}: null or undefined`);
                return;
            }
            // Check if already initialized
            if (container.dataset && container.dataset.cmpInitialized === '1') {
                console.log(`[DEBUG] Container ${idx}: already initialized (has cmpInitialized flag), skipping`);
                return; // avoid double-init
            }
            const media = container.querySelector('.cmp-media');
            const playBtn = container.querySelector('.cmp-play');
            const progress = container.querySelector('.cmp-progress');
            const filled = container.querySelector('.cmp-progress-filled');
            const timeEl = container.querySelector('.cmp-time');
            const volInput = container.querySelector('.cmp-volume');
            const fullscreenBtn = container.querySelector('.cmp-fullscreen');

            if (!media) {
                console.log(`[DEBUG] Container ${idx}: no .cmp-media element found`);
                return;
            }
            const src = media.src || (media.querySelector('source') && media.querySelector('source').src);
            console.log(`[DEBUG] Initializing media player ${idx}: <${media.tagName}> src="${src}"`);
            media.controls = false;

            function updateTime() {
                const cur = formatTime(media.currentTime || 0);
                const dur = formatTime(media.duration || 0);
                if (timeEl) timeEl.textContent = cur + ' / ' + dur;
                if (filled && media.duration) {
                    const pct = (media.currentTime / media.duration) * 100;
                    filled.style.width = pct + '%';
                    progress.setAttribute('aria-valuenow', Math.floor(pct));
                }
            }

            playBtn && playBtn.addEventListener('click', function(e){
                e.preventDefault();
                if (media.paused) { media.play(); playBtn.textContent = '‚è∏'; }
                else { media.pause(); playBtn.textContent = '‚ñ∂'; }
            });

            media.addEventListener('play', () => { if (playBtn) playBtn.textContent = '‚è∏'; });
            media.addEventListener('pause', () => { if (playBtn) playBtn.textContent = '‚ñ∂'; });
            media.addEventListener('timeupdate', updateTime);
            media.addEventListener('loadedmetadata', updateTime);
            media.addEventListener('ended', () => { if (playBtn) playBtn.textContent = '‚ñ∂'; });
            
            // Safari compatibility: update time more frequently
            media.addEventListener('play', () => {
                const timer = setInterval(() => {
                    if (media.paused) {
                        clearInterval(timer);
                    } else {
                        updateTime();
                    }
                }, 500);
            });

            // Seek on progress click
            if (progress) {
                progress.addEventListener('click', function(e){
                    const rect = progress.getBoundingClientRect();
                    const x = (e.clientX - rect.left);
                    const pct = x / rect.width;
                    if (media.duration) media.currentTime = pct * media.duration;
                    updateTime();
                });
            }

            // Volume control
            if (volInput) {
                volInput.addEventListener('input', function(){
                    media.volume = parseFloat(volInput.value);
                });
            }

            // Fullscreen for video
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', function(){
                    const video = media;
                    if (video.requestFullscreen) video.requestFullscreen();
                    else if (video.webkitEnterFullscreen) video.webkitEnterFullscreen();
                });
            }

            // Prevent accidental dragging on mobile
            ['touchmove','touchstart'].forEach(ev => container.addEventListener(ev, e => e.stopPropagation()));
            // pause other players when this one starts
            media.addEventListener('play', () => pauseAllOtherMedia(media));
            
            // Load metadata immediately so duration shows before play
            media.load();
            // Also try to get duration from mediaElement if available
            if (media.duration && isFinite(media.duration)) {
                updateTime();
            }
            
            // For browsers that don't immediately have duration, wait for loadedmetadata
            const metadataHandler = () => {
                console.log(`[DEBUG] Player ${idx}: metadata event fired, duration=${media.duration}`);
                updateTime();
            };
            media.addEventListener('loadedmetadata', metadataHandler);
            media.addEventListener('canplay', metadataHandler);
            media.addEventListener('durationchange', metadataHandler);
            
            // Safari polyfill: check duration periodically until it's loaded
            let metadataCheckCount = 0;
            const metadataChecker = setInterval(() => {
                metadataCheckCount++;
                if (media.duration && isFinite(media.duration)) {
                    console.log(`[DEBUG] Player ${idx}: duration detected via polling (attempt ${metadataCheckCount}): ${media.duration}`);
                    updateTime();
                    clearInterval(metadataChecker);
                } else if (metadataCheckCount > 20) {
                    // Give up after 2 seconds of checking
                    console.log(`[DEBUG] Player ${idx}: giving up on metadata loading after ${metadataCheckCount} attempts`);
                    clearInterval(metadataChecker);
                }
            }, 100);
            
            container.dataset.cmpInitialized = '1';
            console.debug && console.debug('initialized cmp for', container, media);
        });
    }

    // Run upgrade & init on DOMContentLoaded and after dynamic content changes
    function runUpgradeAndInit() {
        console.log('[DEBUG] runUpgradeAndInit called');
        try { upgradeNativeMediaElements(); } catch (e) { console.error(e); }
        try { initializeMediaPlayers(); } catch (e) { console.error(e); }
    }

    // NOTE: The main initialization happens in the initializeApp section above.
    // This is kept as a helper function for reinitializing after dynamic content.

    // Upgrade native <audio> or <video> elements into our custom player wrapper
    function upgradeNativeMediaElements(root=document) {
        // audio
        root.querySelectorAll('audio.message-audio, audio').forEach(orig => {
            // skip if already inside custom player or already converted
            if (orig.closest('.custom-media-player')) return;
            try {
                const container = document.createElement('div');
                container.className = 'custom-media-player';
                container.setAttribute('data-type', 'audio');

                // create fresh audio element and copy src (avoids clone issues)
                const media = document.createElement('audio');
                media.className = 'cmp-media';
                media.preload = 'metadata';
                media.playsInline = true;
                // copy src from source or from orig
                const srcEl = orig.querySelector && orig.querySelector('source');
                const src = (srcEl && srcEl.src) || orig.currentSrc || orig.src || (orig.getAttribute && orig.getAttribute('src')) || '';
                if (src) {
                    const s = document.createElement('source');
                    s.src = src;
                    // try to preserve type if available
                    if (srcEl && srcEl.type) s.type = srcEl.type;
                    media.appendChild(s);
                }

                // build controls
                const controls = document.createElement('div');
                controls.className = 'cmp-controls';
                controls.innerHTML = '<button class="cmp-play" aria-label="Play">‚ñ∂</button>' +
                    '<div class="cmp-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div class="cmp-progress-filled"></div></div>' +
                    '<div class="cmp-time">0:00 / 0:00</div>' +
                    '<div class="cmp-volume-wrap"><input type="range" class="cmp-volume" min="0" max="1" step="0.01" value="1" aria-label="Volume"></div>';

                container.appendChild(media);
                container.appendChild(controls);

                orig.parentNode.replaceChild(container, orig);
                // ensure metadata is loaded
                try { media.load(); } catch (e) {}
            } catch (e) { console.error('upgrade audio failed', e); }
        });

        // video
        root.querySelectorAll('video').forEach(orig => {
            if (orig.closest('.custom-media-player')) return;
            try {
                const container = document.createElement('div');
                container.className = 'custom-media-player video-player';
                container.setAttribute('data-type', 'video');

                const media = document.createElement('video');
                media.className = 'cmp-media';
                media.preload = 'metadata';
                media.playsInline = true;
                const srcEl = orig.querySelector && orig.querySelector('source');
                const src = (srcEl && srcEl.src) || orig.currentSrc || orig.src || (orig.getAttribute && orig.getAttribute('src')) || '';
                if (src) {
                    const s = document.createElement('source');
                    s.src = src;
                    if (srcEl && srcEl.type) s.type = srcEl.type;
                    media.appendChild(s);
                }

                const controls = document.createElement('div');
                controls.className = 'cmp-controls';
                controls.innerHTML = '<button class="cmp-play" aria-label="Play">‚ñ∂</button>' +
                    '<div class="cmp-progress" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div class="cmp-progress-filled"></div></div>' +
                    '<div class="cmp-time">0:00 / 0:00</div>' +
                    '<div class="cmp-volume-wrap"><input type="range" class="cmp-volume" min="0" max="1" step="0.01" value="1" aria-label="Volume"></div>' +
                    '<button class="cmp-fullscreen" aria-label="Fullscreen">‚§¢</button>';

                container.appendChild(media);
                container.appendChild(controls);

                orig.parentNode.replaceChild(container, orig);
                // ensure metadata is loaded
                try { media.load(); } catch (e) {}
            } catch (e) { console.error('upgrade video failed', e); }
        });

        // After upgrade, initialize players in the new containers
        initializeMediaPlayers();
    }

    // Watch for new messages added to container and upgrade their media
    try {
        const messagesNode = document.getElementById('messages');
        if (messagesNode) {
            const obs = new MutationObserver(muts => {
                muts.forEach(m => {
                    if (m.addedNodes && m.addedNodes.length) {
                        m.addedNodes.forEach(n => {
                            if (n.querySelector) upgradeNativeMediaElements(n);
                        });
                    }
                });
            });
            obs.observe(messagesNode, { childList: true, subtree: true });
        }
    } catch (e) { console.error('media observer setup failed', e); }

    // === –Ø–≤–Ω–æ–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–π –Ω–∞ window –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ onclick ===
    window.sendMessage = sendMessage;
    window.addFilePreview = addFilePreview;
    window.removeFilePreview = removeFilePreview;
    window.updateFilePreviewArea = updateFilePreviewArea;
    window.uploadAndSendFile = uploadAndSendFile;
    window.deleteMessage = deleteMessage;
    window.showFullscreen = showFullscreen;
    window.previewFile = previewFile;
    window.showProfile = showProfile;
    window.editChannel = editChannel;
    window.saveChannelEdit = saveChannelEdit;
    window.deleteChannel = deleteChannel;
    window.inviteToRoom = inviteToRoom;
    window.showConfirm = showConfirm;
    window.closeConfirmModal = closeConfirmModal;
    window.showAlert = showAlert;
    window.closeAlertModal = closeAlertModal;
    window.showContextMenu = showContextMenu;
    window.hideContextMenu = hideContextMenu;
    window.copyMessage = copyMessage;
    window.editMessage = editMessage;
    window.forwardMessage = forwardMessage;
    window.deleteMessageFromMenu = deleteMessageFromMenu;
    window.toggleReaction = toggleReaction;
    window.toggleStickerPicker = toggleStickerPicker;
    window.showReactionPicker = showReactionPicker;
    window.saveEditedMessage = saveEditedMessage;
</script>

{% endblock %}